<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Dsljlbaby's Blog]]></title>
  <subtitle><![CDATA[只有行动才能证明一切]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dsljlbaby.github.io/"/>
  <updated>2016-02-16T03:26:36.891Z</updated>
  <id>http://dsljlbaby.github.io/</id>
  
  <author>
    <name><![CDATA[Dsljlbaby]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[集体编程智慧笔记（二）]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/15/%E9%9B%86%E4%BD%93%E7%BC%96%E7%A8%8B%E6%99%BA%E6%85%A7%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://dsljlbaby.github.io/2016/02/15/集体编程智慧笔记（二）/</id>
    <published>2016-02-15T08:30:54.000Z</published>
    <updated>2016-02-16T03:26:36.891Z</updated>
    <content type="html"><![CDATA[<p>《集体智慧编程》的第二章“提供推荐”主要讲解如何利用<strong>协作型过滤</strong>技术构建一个根据群体偏好来为人们提供推荐的系统。</p>
<h1 id="u534F_u4F5C_u578B_u8FC7_u6EE4"><a href="#u534F_u4F5C_u578B_u8FC7_u6EE4" class="headerlink" title="协作型过滤"></a>协作型过滤</h1><p>协作型过滤(collaborative filtering)是David Goldberg 1992年在施乐帕克研究所中心的一篇题为《Using collaborative filtering to weave an information tapestry》的论文中提出的，他设计了一个名为Tapestry的系统，该系统允许人们根据自己对文档感兴趣的程度为其添加标注，并利用这一信息为他人进行文档过滤。</p>
<p>协作型过滤技术的做法：对一大群人进行搜索，并从其中找出与我们品味相近的一小群人。算法对这些人所偏爱的其它内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表。</p>
<p>协作型过滤技术要考虑的两个重点：一是寻找一个表达不同人及其偏好的方法；二是确定人们在品味方面的相似程度。</p>
<h2 id="u641C_u7D22_u504F_u597D"><a href="#u641C_u7D22_u504F_u597D" class="headerlink" title="搜索偏好"></a>搜索偏好</h2><p>如果我们要做一个影片观赏推荐系统，第一步应该是寻找一个表达不同人及其偏好的方法，而在Python中，实现这一目的的方法是构建一个<em>嵌套字典</em>。下面示例构建了一个涉及影评者及评分情况的字典，影评者对电影的喜爱程度用０－５表示，５表示喜爱程度最高，０表示喜爱程度最低。</p>
<pre><code>#　一个涉及影评者及评分情况的字典
critics = {
       &apos;Lisa Rose&apos;:{&apos;Lady in the Water&apos;:2.5,&apos;Snakes on the a Plane&apos;:3.5,&apos;Just My Luck&apos;:3.0,&apos;Superman Returns&apos;:3.5,&apos;You, Me and Durpree&apos;:2.5,&apos;The Night Listener&apos;:3.0},
       &apos;Gene Seymour&apos;:{&apos;Lady in the Water&apos;:3.0,&apos;Snakes on the a Plane&apos;:3.5,&apos;Just My Luck&apos;:1.5,&apos;Superman Returns&apos;:5.0,&apos;You, Me and Durpree&apos;:3.5,&apos;The Night Listener&apos;:3.0},
       &apos;Michael Phillips&apos;:{&apos;Lady in the Water&apos;:2.5,&apos;Snakes on the a Plane&apos;:3.0,&apos;Superman Returns&apos;:3.5,&apos;The Night Listener&apos;:4.0},
       &apos;Claudia Puig&apos;:{&apos;Snakes on the a Plane&apos;:3.5,&apos;Just My Luck&apos;:3.0,&apos;Superman Returns&apos;:4.0,&apos;You, Me and Durpree&apos;:2.5,&apos;The Night Listener&apos;:4.5},
       &apos;Mick LaSallpe&apos;:{&apos;Lady in the Water&apos;:3.0,&apos;Snakes on the a Plane&apos;:4.0,&apos;Just My Luck&apos;:2.0,&apos;Superman Returns&apos;:3.0,&apos;You, Me and Durpree&apos;:2.0,&apos;The Night Listener&apos;:3.0},
       &apos;Jack Matthews&apos;:{&apos;Lady in the Water&apos;:3.0,&apos;Snakes on the a Plane&apos;:4.0,&apos;Superman Returns&apos;:5.0,&apos;You, Me and Durpree&apos;:3.5,&apos;The Night Listener&apos;:3.0},
       &apos;Toby&apos;:{&apos;Snakes on the a Plane&apos;:4.5,&apos;Superman Returns&apos;:4.0,&apos;You, Me and Durpree&apos;:1.0}
       }
</code></pre><h2 id="u786E_u5B9A_u76F8_u4F3C_u5EA6"><a href="#u786E_u5B9A_u76F8_u4F3C_u5EA6" class="headerlink" title="确定相似度"></a>确定相似度</h2><p>在搜集完人们的偏好数据之后，我们接下来要对这些数据进行处理，即计算人们在品味方面的相似度评价值。我们采用两种计算相似度评价值的算法：<strong>欧几里德距离</strong>和<strong>皮尔逊相关度</strong>。</p>
<h3 id="u6B27_u51E0_u91CC_u5FB7_u8DDD_u79BB_u8BC4_u4EF7"><a href="#u6B27_u51E0_u91CC_u5FB7_u8DDD_u79BB_u8BC4_u4EF7" class="headerlink" title="欧几里德距离评价"></a>欧几里德距离评价</h3><p>欧几里德距离是指多维空间中两点间的距离。</p>
<p>算法实现：</p>
<pre><code>def euclidean(p, q):
    sumSq = 0.0
    # 将差值的平方累加
    for i in range(len(p)):
        sumSq += (p[i]-q[i])**2
    # 求平方根
    return (sumSq**0.5)
</code></pre><p>如果两个人的兴趣偏好越接近，则它们的欧几里德距离越短。</p>
<p>假设两个人的兴趣偏好完全相同，它们的欧几里德距离则为零。而我们想要定义一个函数，来对偏好越相近的情况给出越大的值(取倒数)，为了避免除零错误，我们需要对欧几里德计算出的函数值加一，然后对其取倒数。</p>
<p>函数实现：</p>
<pre><code>from math import sqrt

# 基于欧几里得距离的相似度计算
def sim_distance(prefs,person1,person2):
    si = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
            si[item] = 1

    # 如果两者没有共同之处，返回0
    if len(si) == 0:
        return 0

    # 计算所有差值的平方和
    sum_of_squares = sum ([pow(prefs[person1][item] - prefs[person2][item],2) for item in prefs[person1] if item in prefs[person2]])
    return 1 / (1 + sqrt(sum_of_squares))
</code></pre><h3 id="u76AE_u5C14_u900A_u76F8_u5173_u7CFB_u6570_u8BC4_u4EF7"><a href="#u76AE_u5C14_u900A_u76F8_u5173_u7CFB_u6570_u8BC4_u4EF7" class="headerlink" title="皮尔逊相关系数评价"></a>皮尔逊相关系数评价</h3><p>皮尔逊相关系数是一种度量两个变量间相关程度的方法。它是一个介于1和-1之间的值。其中1表示变量完全正相关，0表示无关，-1表示完全负相关。</p>
<p>该相关系数是判断两组数据与某一直线拟合程度的一种度量。它在数据不是很规范时，会倾于给出更好地结果</p>
<p>算法实现：</p>
<pre><code>def person(x, y):
    n = len(x)
    vals = range(n)
    # 简单求和
    sumx = sum(float(x[i]) for i in vals)
    sumy = sum(float(x[i]) for i in vals)
    # 求平方和
    sumxSq = sum(x[i]**2.0 for i in vals)
    sumySq = sum(y[i]**2.0 for i in vals)
    #求乘积之和
    pSum = sum(x[i]*y[i] fpr i in vals)
    #计算皮尔逊评价值
    num = pSum - (sumx * sumy / n)
    den = ((sumxSq- pow(sumx, 2) / n) * (sumySq - pow(sumy, 2) / 2)) ** 0.5

    if den ==0:
        return 1

    r = num / den
    return r
</code></pre><p>相比于欧几里德距离评价算法，皮尔逊相关系数评价可以修正“夸大分值”的情况。比如:对于电影的影片来说。如果某人总是倾于给出比另一个人更好地分值，而两者的分值之差又始终保持一致，则他们仍旧存在很好的相关性，但是，欧几里德距离评价会因为一个人的评价始终比另一个人的高，而得出两者不相近的结论。</p>
<p>函数实现：</p>
<pre><code># 基于皮尔逊相关系数的相似度计算
def sim_person(prefs,person1,person2):
    si = {}
    for item in prefs[person1]:
        if item in prefs[person2]:
            si[item] = 1

    n = len(si)
    if n == 0:
        return 1

    sum1 = sum([prefs[person1][item] for item in si])
    sum2 = sum([prefs[person2][item] for item in si])

    sum1_sqrt = sum([pow(prefs[person1][item],2) for item in si])
    sum2_sqrt = sum([pow(prefs[person2][item],2) for item in si])

    pSum = sum([prefs[person1][item] * prefs[person2][item] for item in si])

    # 计算皮尔逊相关系数值
    num = pSum - (sum1 * sum2 / n)
    den = sqrt((sum1_sqrt - pow(sum1,2) / n) * (sum2_sqrt - pow(sum2,2) / n))
    if den == 0:
        return 0
    return num / den
</code></pre><h2 id="u76F8_u4F3C_u5EA6_u5EA6_u91CF_u65B9_u6CD5_u7684_u9009_u62E9"><a href="#u76F8_u4F3C_u5EA6_u5EA6_u91CF_u65B9_u6CD5_u7684_u9009_u62E9" class="headerlink" title="相似度度量方法的选择"></a>相似度度量方法的选择</h2><p>我们已经介绍了两种不同的度量方法，实际上，还有更多的度量方法可以衡量两组数据的相似程度。使用哪一种方法，取决于具体的应用。</p>
<p>而作为相似度计算函数，需要他们满足如下条件：拥有同样地函数签名，以一个浮点数作为返回值，其数值越大代表相似度越近。</p>
<h3 id="u504F_u597D_u8005_u6392_u5E8F"><a href="#u504F_u597D_u8005_u6392_u5E8F" class="headerlink" title="偏好者排序"></a>偏好者排序</h3><p>我们已经有了对两个人进行相似度计算的算法，下面我们需要对这些与我们偏好相近的人进行排序，找出与我们相似度最高的人，这样我们就可以在选择时采纳他的建议。</p>
<pre><code># 寻找与自己有相似品味的影评者
def topMatches(prefs,person,n=5,similarity=sim_person):
    scores= [(similarity(prefs,person,other),other) for other in prefs if other != person]

    # 对列表排序
    scores.sort()
    scores.reverse()
    return scores[0:n]
</code></pre><h3 id="u63A8_u8350_u7269_u54C1"><a href="#u63A8_u8350_u7269_u54C1" class="headerlink" title="推荐物品"></a>推荐物品</h3><p>我们找到一个趣味相投的人固然不错，但是在生活中，我们往往需要的不止这个，我们还需要一个真正的物品推荐清单。虽然我们可以从与自己趣味相投的人的物品清单寻找自己满意的物品，但是如果他尚未体验某些物品，而这些物品当中或许有我们喜欢的，那岂不是错过了。</p>
<p>为此，我们可以通过一个经过加权的评价值来为物品打分，然后根据分数的高低去选择性的挑选商品。</p>
<p>相应地，在这个影片推荐的实现系统中，我们的实现步骤：</p>
<ol>
<li>取得所有影评者与自己的相似度</li>
<li>相似度*他们为每部影片的评价值</li>
<li>分别计算他们的每部影片相似度*评价值的总分</li>
<li>总分/相似度之和</li>
<li>对计算结果排序</li>
</ol>
<p>函数实现：</p>
<pre><code># 利用其它评论者的评论值加权平均值，为某人推荐物品
def getRecommendations(prefs,person,similarity=sim_person):
    totals = {}
    simSums = {}
    for other in prefs:
        if other == person:
            continue
        sim = similarity(prefs,person,other)

        if sim &lt;= 0:
            continue
        for item in prefs[other]:
            # 只对某人没有看过的影片进行评价
            if item not in prefs[person] or prefs[person][item] == 0:
                totals.setdefault(item,0)
                totals[item] += prefs[other][item] * sim
                simSums.setdefault(item,0)
                simSums[item] += sim

    # 建立一个归一化的列表
    rankings = [(total / simSums[item],item) for item,total in totals.items()]

    rankings.sort()
    rankings.reverse()
    return rankings
</code></pre><h2 id="u5339_u914D_u5546_u54C1"><a href="#u5339_u914D_u5546_u54C1" class="headerlink" title="匹配商品"></a>匹配商品</h2><p>现在，我们已经知道了如何为指定人员寻找品味相近者，以及如何向其推荐商品的方法，但是如果我们想了解哪些商品是彼此相近的，那又该如何？</p>
<p>在这种情况下，我们可以通过查看哪些人喜欢某一特定物品，以及这些人喜欢哪些其他物品来决定相似度。事实上，只要我们将人员与物品对换，然后利用前面的人与人之间相似度计算方法就可以得到。</p>
<p>转化函数实现：</p>
<pre><code># 将人员与物品调换
def transformPrefs(prefs):
    result = {}
    for person in prefs:
        for item in prefs[person]:
            result.setdefault(item, {})

            result[item][person] = prefs[person][item]
    return result
</code></pre><h3 id="u6784_u5EFA_u6570_u636E_u96C6"><a href="#u6784_u5EFA_u6570_u636E_u96C6" class="headerlink" title="构建数据集"></a>构建数据集</h3><p>为了对物品进行比较，我们需要构造一个包含相近物品的完整数据集。构建完一次后，我们在需要的时候可以反复使用它。</p>
<p>函数实现：</p>
<pre><code># 构建物品比较数据集
def calculateSimilarItems(prefs, n =10):
    result = {} # 建立字典，给出与这些物品相近的其他物品

    # 以物品为中心对偏好矩阵实施倒置处理
    itemPrefs = transformPrefs(prefs)
    c = 0
    for item in itemPrefs:
        # 针对大数据集更新状态变量
        c += 1
        if c % 100 == 0:
            print &quot;%d / %d&quot; % (c, len(itemPrefs))
        # 寻找相近的物品
        scores = topMatches(itemPrefs, item, n=n, similarity = sim_distance)
        result[item] = socres
    return result
</code></pre><p>这个函数利用之前定义的transformPrefs函数，对反映评价值的字典进行倒置，得到一个关于物品及其用户评价情况的列表。然后，程序遍历每项物品，并将转换了的字典传入topMatches函数，求得最为相近的物品及其相似度评价值。最后，返回一个包含物品及其相近物品列表的字典。</p>
<h3 id="u83B7_u5F97_u63A8_u8350"><a href="#u83B7_u5F97_u63A8_u8350" class="headerlink" title="获得推荐"></a>获得推荐</h3><p>函数getRecommendedItems实现基于物品寻找推荐的过程,与之前的getRecommendations函数实现算法基本相似。</p>
<p>函数实现：</p>
<pre><code># 基于物品的推荐
def getRecommendedItems(prefs, itemMatch, user):
    userRatings = prefs[user]
    scores = {}
    totalSim = {}

    # 循环遍历由当前用户评分的物品
    for (item, rating) in userRatings.items():
        # 循环遍历与当前物品相近的物品
        for (similarity, item2) in itemMatch[item]:
            # 如果该用户对当前物品做过评价，则忽略
            if item2 in userRatings:
                continue
            # 评价值与相似度的加权之和
            scores.setdefault(item2, 0)
            scores[item2] += similarity * rating
            # 全部相似度之和
            totalSim.setdefault(item2, 0)
            totalSim[item2] += similarity
    # 求出加权平均值
    rankings = [(score / totalSim[item], item) for item, score in scores.items()]

    # 对评分结果排序并返回
    rankings.sort()
    rankings.reverse()
    return rankings
</code></pre><h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>对于稀疏数据集，基于物品的过滤方法通常要优于基于用户的过滤方法，而对于密集数据集而言，两者的效果几乎一样。基于用户的过滤方法更易于实现，无需额外的步骤，所以它通常更适用于规模较小的变化非常频繁的内存数据集。</p>
<p>现在，我们学会了如何计算相似度评价值，以及如何利用他们对用户和物品进行比较。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《集体智慧编程》的第二章“提供推荐”主要讲解如何利用<strong>协作型过滤</strong>技术构建一个根据群体偏好来为人们提供推荐的系统。</p>
<h1 id="u534F_u4F5C_u578B_u8FC7_u6EE4"><a href="#u534F_u4F5C]]>
    </summary>
    
      <category term="协作型过滤" scheme="http://dsljlbaby.github.io/tags/%E5%8D%8F%E4%BD%9C%E5%9E%8B%E8%BF%87%E6%BB%A4/"/>
    
      <category term="欧几里德距离，皮尔逊相关系数" scheme="http://dsljlbaby.github.io/tags/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E8%B7%9D%E7%A6%BB%EF%BC%8C%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[集体智慧编程笔记（一）]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/15/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://dsljlbaby.github.io/2016/02/15/集体智慧编程笔记（一）/</id>
    <published>2016-02-15T07:00:16.000Z</published>
    <updated>2016-02-15T08:08:29.520Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本书获得了巨大的成功，它为大量相关数据的处理提供了非常丰富的计算方法。更重要的是，它将这些技术应用到了互联网上，而不是在一个个彼此孤立的数据孤岛中寻求价值。 ——Paul Tyma</p>
</blockquote>
<p>《集体智慧编程》这本书以Web2.0的核心价值观——集体智慧作为出发点，探求了各种让Web2.0程序变得更为智能的算法及应用。涉及到的算法包括了过滤器、聚类算法、支持向量机、遗传编程、优化技术以及PageRank算法等。本书的一大亮点就是将如此众多的优秀算法有效应用于互联网领域，并构造出具有智能特征的Web2.0应用，此外，代码示例使用Python语言编写的，有助于我们对Python语言的进阶学习和算法掌握，书中代码大量使用当前流行的开放API，使得本书的使用性极高。作者使用浅显易懂的方式解释了涉及机器学习等方面的数学概念，同时运用了生活常见的案例使得我们学习的兴趣大大增加。</p>
<p>本书分为十二章：</p>
<ul>
<li>集体智慧导言</li>
</ul>
<p>简单地介绍了机器学习的相关概念，解释了如何将其应用于不同的领域，以及如何利用它对搜索自不同人群的数据进行处理和结论。</p>
<ul>
<li>提供推荐</li>
</ul>
<p>本章介绍了<strong>协作性过滤</strong>技术，这项技术被许多在线零售商用来向顾客推荐商品或者媒体。通过欧几里德评价和皮尔逊相关系数理解了这一技术的应用。</p>
<ul>
<li>发现群组</li>
</ul>
<p>本章在第二章的基础上，介绍了两种不同的<strong>聚类方法</strong>，利用这些方法，我们可以在一个大数据集中自动找出具有相似特征的群组。演示了如何利用聚类算法从一个颇受欢迎的博客中寻找群组以及利用聚类算法根某个社会型网站的用户意愿去寻找群组。</p>
<ul>
<li>搜索与排名</li>
</ul>
<p>本章描述了一个搜索引擎的各个不同组成部分：爬虫程序、索引程序以及查询程序。介绍了来自外部网站的链接信息为依据给网页打分的<strong>PageRank算法</strong>和如何构建神经网络，借此获知与不同结果相关联的关键字。</p>
<ul>
<li>优化</li>
</ul>
<p>本章介绍了<strong>优化算法</strong>，演示了这些算法的不同用法：为一群去往相同地点的旅客寻找最佳航班、寻求为学生安排宿舍的最佳方案以及给出交叉数量最小的网络布局。</p>
<ul>
<li>文档过滤</li>
</ul>
<p>本章介绍了<strong>贝叶斯过滤</strong>，此算法可以应用于垃圾信息过滤系统。作者将其应用于一组RSS搜索结果，来说明对内容项的自动分类过程。</p>
<ul>
<li>决策树建模</li>
</ul>
<p>本章介绍了<strong>决策树</strong>，它不仅可以作为一种预测方法，还可以用它为决策过程建模。</p>
<ul>
<li>构建价格模型</li>
</ul>
<p>本章解决的是数值预测问题，涉及到了<strong>K-最近邻技术</strong>，利用优化算法和它构建出一个可以根据拍卖品的一组属性，预测最终的拍卖价格的系统。</p>
<ul>
<li>高阶分类：核方法与SVM</li>
</ul>
<p>本章介绍了如何利用<strong>支持向量机</strong>对在线约会网站的用户进行匹配，以及如何将其用于针对专业交友网站的好友信息搜索。</p>
<ul>
<li>寻找独立特征</li>
</ul>
<p>本章介绍了<strong>非负矩阵因式分解</strong>，用它在数据集中寻找独立的特征。</p>
<ul>
<li>智能进化</li>
</ul>
<p>本章介绍了<strong>遗传编程</strong>，该技术超出了优化的范畴，借鉴进化的思想，通过自动构造算法的方式解决特定的问题。</p>
<ul>
<li>算法总结</li>
</ul>
<p>本章主要回顾了书中所讲述的所有机器学习算法和统计算法，并将它们与一组人为设计的问题作了对比，形象地说明了每种算法划分数据的方法。</p>
<blockquote>
<p>Toby的这本书非常成功地将机器学习算法这一复杂的议题拆分成一个个既实用又易懂得例子，我们可以直接利用这些例子来分析当前网络上的社会化交互作用。  ———Tim Wolters</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本书获得了巨大的成功，它为大量相关数据的处理提供了非常丰富的计算方法。更重要的是，它将这些技术应用到了互联网上，而不是在一个个彼此孤立的数据孤岛中寻求价值。 ——Paul Tyma</p>
</blockquote>
<p>《集体智慧编程》这本书以]]>
    </summary>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/tags/Python/"/>
    
      <category term="机器学习" scheme="http://dsljlbaby.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="集体智慧编程" scheme="http://dsljlbaby.github.io/tags/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之正则表达式]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/13/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://dsljlbaby.github.io/2016/02/13/Python学习笔记之正则表达式/</id>
    <published>2016-02-13T09:28:20.000Z</published>
    <updated>2016-02-14T04:26:27.027Z</updated>
    <content type="html"><![CDATA[<p>随着互联网的发展，信息大爆炸来临，需要我们处理的文本或数据越来越多，仅仅靠人工处理已变成泡沫，如果能够通过计算机编程来处理这些内容，我们不免感到一丝欣慰，而正则表达式为高级文本模式匹配提供了基础，我们需要简单地掌握这一方程式。</p>
<h1 id="u6B63_u5219_u8868_u8FBE_u5F0F_28re_29"><a href="#u6B63_u5219_u8868_u8FBE_u5F0F_28re_29" class="headerlink" title="正则表达式(re)"></a>正则表达式(re)</h1><p>正则表达式是一些由字符和特殊符号组成的字符串，它们描述了这些字符和字符的某种重复方式，因此能按某种模式匹配一个有相似特征的字符串。</p>
<h1 id="u5143_u5B57_u7B26"><a href="#u5143_u5B57_u7B26" class="headerlink" title="元字符"></a>元字符</h1><p>元字符包括了特殊字符和符号，正是他们赋予了正则表达式强大的功能和灵活性。</p>
<ul>
<li>管道符号(|)</li>
</ul>
<p>它的实现功能类似于逻辑操作符“或”，选择被管道符号分隔的多个不同的正则表达式中的一个。</p>
<pre><code>Python | Java | C++ 匹配的字符为 Python或Java或C++
</code></pre><ul>
<li>单个任意匹配符号(.)</li>
</ul>
<p>点符号(.)匹配除了换行符之外的任意单个字符。</p>
<pre><code>P.y  匹配在P和y之间的任意字符，如P0y，Pcy,P&amp;y...

start. 匹配在字符串start之后的任意单个字符

.end 匹配在字符串end之前的任意单个字符
</code></pre><ul>
<li>匹配字符串的开始(^) </li>
</ul>
<p>使用匹配符^匹配以某一字符开始的字符串</p>
<pre><code>^py 匹配以py开头的字符串
</code></pre><ul>
<li>匹配字符串的结束($)</li>
</ul>
<p>使用匹配符$匹配以某一字符结束的字符串</p>
<pre><code>py$ 匹配以py结束的字符串
</code></pre><ul>
<li>特殊字符\b和\B</li>
</ul>
<p>\b匹配的模式是一个单词边界，\B只匹配出现在一个单词中间的模式。</p>
<pre><code>\bthe 任何以&apos;the&apos;开始的字符串
\bthe\b 仅匹配单词&apos;the&apos;
\Bthe 任意包含&apos;the&apos;但不以&apos;the&apos;开头的单词
</code></pre><ul>
<li>创建字符类([])</li>
</ul>
<p>尽管点符号可以匹配任意字符，但有时候需要匹配某些特殊的字符，使用方括号会匹配方括号内的任意一个字符。</p>
<pre><code>b[ai]t 匹配的字符为bat, bit
</code></pre><ul>
<li>指定范围(-)</li>
</ul>
<p>方括号除了匹配单个字符外，还可以匹配所指定的字符范围。</p>
<pre><code>z.[0-9] 字符z后面包括任意单个字符，然后是一个十进制的数字。
[0-9a-zA-Z] 匹配一个十进制数字或大小写字母
</code></pre><ul>
<li>否定匹配符[^]</li>
</ul>
<p>不匹配此字符集中出现的任何一个字符或字符范围。</p>
<pre><code>b[^ai]t 匹配的字符串不包括bat或bit
b[A-Z]t 匹配的字符中不包括大写字母
</code></pre><ul>
<li>闭包操作符(+, ?, *, {})</li>
</ul>
<p>特殊字符”+”匹配前面出现的正则表达式一次或多次；</p>
<p>特殊字符”?”匹配前面出现的正则表达式零次或一次；</p>
<p>特殊字符”*”匹配前前面出现的正则表达式零次或多次；</p>
<p>特殊字符”{N}”匹配前面出现的正则表达式N次；</p>
<p>特殊字符”{M:N}”匹配前面出现的正则表达式M到N次。</p>
<p>特殊字符”*+?{m,n}”匹配尽量多的字符，即贪心模式</p>
<p>注意：特殊字符”?”有两个含义：1、单独使用表示匹配出现零次或一次；2、紧跟在表示重复的元字符后面时，表示要求搜索引擎匹配的字符串越短越好。</p>
<ul>
<li>特殊字符集<br>\d 表示匹配任何数字，与[0-9]相同，\D与之相反<br>\w 表示匹配任何数字字母字符，与[0-9A-Za-z]相同，\W与之相反<br>\s 表示匹配任何空白符，\S与之相反</li>
</ul>
<h1 id="re_u6A21_u5757"><a href="#re_u6A21_u5757" class="headerlink" title="re模块"></a>re模块</h1><p>简单地了解下re模块中最常用的几个函数(方法)，如match()、search()、compile()等。</p>
<h2 id="compile_28_29"><a href="#compile_28_29" class="headerlink" title="compile()"></a>compile()</h2><p>Python的代码最终是要被编译成字节码，然后才能被解释器执行。</p>
<p>当执行字符串形式的代码时，每次都必须对这些代码进行字节编译处理，而compile()函数则提供了一次性字节代码预编译，compile有三个必需参数，第一个参数代表了要编译的Python代码，第二个参数虽然是必须的，但是通常被置为空串，该参数代表存放代码对象的文件的名字，第三个参数是用来表示代码对象的类型，有三个值可选择，分别为’eval’可求值得表达式(和eval()一起使用)’single’单一可执行语句(和exec一起使用)’exec’可执行语句组(和exec一起使用)</p>
<pre><code>1、可求值表达式
&gt;&gt;&gt; eval_code = compile(&apos;200 + 300&apos;, &apos;&apos;, &apos;eval&apos;)
&gt;&gt;&gt; eval(eval_code)
500

2、单一执行语句
&gt;&gt;&gt; single_code = compile(&apos;print &quot;Hello world&quot;&apos;, &apos;&apos;, &apos;single&apos;)
&gt;&gt;&gt; exec single_code
Hello world

3、可执行语句块
&gt;&gt;&gt; exec_code = compile(&quot;&quot;&quot;
... req = input(&apos;Count how many numbers?&apos;)
... for eachNum in range(req):
...     print eachNum
... &quot;&quot;&quot;, &apos;&apos;, &apos;exec&apos;)

&gt;&gt;&gt; exec exec_code
Count how many numbers? 3
0
1
2
</code></pre><h2 id="match_28_29_u3001group_28_29_u3001groups_28_29"><a href="#match_28_29_u3001group_28_29_u3001groups_28_29" class="headerlink" title="match()、group()、groups()"></a>match()、group()、groups()</h2><p>match()函数从字符串的开头开始匹配，如果匹配成功，返回一个匹配对象，如果匹配失败，返回None。</p>
<p>group()函数返回所有匹配对象或者是根据要求返回某个特定子组。</p>
<p>groups()函数返回一个包含唯一或所有子组的元组。</p>
<p>如果正则表达式中没有子组的话，group()返回全部匹配对象，groups()返回一个空元组。</p>
<pre><code>&gt;&gt;&gt; re.match(&apos;hi&apos;, &apos;his name is hisa&apos;).group()
&apos;hi&apos;
&gt;&gt;&gt; re.match(&apos;hi&apos;, &apos;his name is hisa&apos;).groups()
()
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>随着互联网的发展，信息大爆炸来临，需要我们处理的文本或数据越来越多，仅仅靠人工处理已变成泡沫，如果能够通过计算机编程来处理这些内容，我们不免感到一丝欣慰，而正则表达式为高级文本模式匹配提供了基础，我们需要简单地掌握这一方程式。</p>
<h1 id="u6B63_u5219]]>
    </summary>
    
      <category term="正则表达式" scheme="http://dsljlbaby.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之类]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/13/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B1%BB/"/>
    <id>http://dsljlbaby.github.io/2016/02/13/Python学习笔记之类/</id>
    <published>2016-02-13T03:03:01.000Z</published>
    <updated>2016-02-13T07:39:41.753Z</updated>
    <content type="html"><![CDATA[<p>对于学习过C++或者Java等高级语言的人来说，面向对象可能不是那么陌生，但是没有接触过编程语言或只是简单地了解C语言的人可能不是很了解面向对象。C语言是一种面向过程的设计语言，而C++是一门面向对象的编程语言，面向对象的设计核心更注重于人类的思维，即我们有必要了解下这一编程范式。</p>
<h1 id="u7C7B_28class_29"><a href="#u7C7B_28class_29" class="headerlink" title="类(class)"></a>类(class)</h1><p>编程的发展已经由简单控制流中按步的指令序列进入到更有组织的方式中，依靠代码块可以形成命名子程序和完成既定的功能。结构化的或过程性编程可以让我们把程序组织成逻辑块，以便重复使用或重用。面向对象编程在某种程度上增强了结构化编程，实现了数据与动作的融合：数据层和逻辑层由一个可用以创建这些对象的简单抽象层来描述。面向对象设计提供了建模和解决现实世界问题和情形的途径。</p>
<p>类是现实世界的抽象的实体以编程形式出现。类和实例相互关联，类是对象的定义，实例是这些对象的具体化。例如：猫、白猫和黑猫的关系，猫-类，白猫或黑猫-实例。</p>
<h1 id="u7C7B_u7684_u521B_u5EFA"><a href="#u7C7B_u7684_u521B_u5EFA" class="headerlink" title="类的创建"></a>类的创建</h1><p>Python中使用class关键字来创建类：</p>
<pre><code>calss ClassName(base): # 新式类
    &apos;class documentation string&apos;  # 类文档字符串
    class_suit # 类体

calss ClassName: # 经典类
    &apos;class documentation string&apos;  # 类文档字符串
    class_suit # 类体

新式类和经典类的唯一区别在于新式类必须继承至少一个父类，参数base可以是单继承也可以是多继承，如果没有继承任何父类，默认为object。
</code></pre><h1 id="u7C7B_u7684_u5B9E_u4F8B_u5316"><a href="#u7C7B_u7684_u5B9E_u4F8B_u5316" class="headerlink" title="类的实例化"></a>类的实例化</h1><p>创建一个实例的过程被称为实例化。</p>
<pre><code>class Person(object):
    &apos;define Person classic class&apos;
    pass

person1 = Person()
实例化类似于函数调用，通常会把这个新建的实例赋值给一个变量，如果我们没有将这个实例保存到一个变量中，它很快会被自动垃圾收集器回收，保存到一个变量相当于为这个实例分配了一块内存。
</code></pre><h1 id="u7C7B_u5C5E_u6027"><a href="#u7C7B_u5C5E_u6027" class="headerlink" title="类属性"></a>类属性</h1><p>属性就是属于另一个对象的数据或者函数元素，可以通过”.”属性表示符进行访问。</p>
<h2 id="u6570_u636E_u5C5E_u6027"><a href="#u6570_u636E_u5C5E_u6027" class="headerlink" title="数据属性"></a>数据属性</h2><p>数据属性是所定义的类的变量，像所有的变量一样在类创建后进行访问。这种属性类似于其他面对对象编程语言中的静态变量，不依赖于任何类实例，是与它们所属的类对象绑定的。</p>
<pre><code>&gt;&gt;&gt; class Person(object):
        name = &apos;Joe&apos;

&gt;&gt;&gt; Person.name
&apos;Joe&apos;
</code></pre><h2 id="u5B9E_u4F8B_u5C5E_u6027"><a href="#u5B9E_u4F8B_u5C5E_u6027" class="headerlink" title="实例属性"></a>实例属性</h2><pre><code>&gt;&gt;&gt; class Person(object):
        def __init__(self, name, phone):
            self.name = name
            self.phone = phone
            print &apos;Created instance for:&apos;, self.name
        def UpdataPhone(self, newphone):
            self.phone = newphone
            peinr &apos;Updated phone# for:&apos;, self.name

&gt;&gt;&gt; Joe = Person(&apos;Joe&apos;, &apos;400-238-188&apos;)
Created instance for: Joe
&gt;&gt;&gt; Joe
&lt;__main__.Person object at 0x02C62B10&gt;
&gt;&gt;&gt; Joe.name
&apos;Joe&apos;
&gt;&gt;&gt; Joe.phone
&apos;400-238-188&apos;
</code></pre><h2 id="u65B9_u6CD5_u5C5E_u6027"><a href="#u65B9_u6CD5_u5C5E_u6027" class="headerlink" title="方法属性"></a>方法属性</h2><p>在Python的类中所定义的函数被称为方法。方法一般是通过”.”标识符和它的实例绑定的。方法的实现途径分为以下三步：</p>
<ol>
<li>定义类</li>
<li>创建实例</li>
<li>使用实例调用方法。</li>
</ol>
<p>-</p>
<pre><code>&gt;&gt;&gt; class Person(object):
        def __init__(self, name, phone):
            self.name = name
            self.phone = phone
            print &apos;Created instance for:&apos;, self.name
        def UpdataPhone(self, newphone):
            self.phone = newphone
            peinr &apos;Updated phone# for:&apos;, self.name

&gt;&gt;&gt; Joe = Person(&apos;Joe&apos;, &apos;400-238-188&apos;)
Created instance for: Joe
&gt;&gt;&gt; Joe.UpdataPhone(&apos;400-222-123&apos;)
Updated phone# for: Joe
&gt;&gt;&gt; Joe.phone
&apos;400-222-123&apos;
</code></pre><p>你可能注意到在所有的方法中都有self这个参数，但是我们在调用时并没有给他传递任何参数，是因为这个参数代表实例对象本身，当你调用方法时，由解释器悄悄地传递给方法的，相等于其他语言中的”this”。</p>
<p>注意：Python严格要求，没有实例，方法是不能被调用的。</p>
<h2 id="u67E5_u770B_u7C7B_u5C5E_u6027"><a href="#u67E5_u770B_u7C7B_u5C5E_u6027" class="headerlink" title="查看类属性"></a>查看类属性</h2><p>要知道一个类有哪些属性，我们通常通过使用dir()内建函数或者访问类的字典属性<code>__dict__</code>查看。</p>
<pre><code>&gt;&gt;&gt; dir(Person)
[&apos;UpdataPhone&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;]
&gt;&gt;&gt; print Person.__dict__
{&apos;__module__&apos;: &apos;__main__&apos;, &apos;UpdataPhone&apos;: &lt;function UpdataPhone at 0x02C64670&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Person&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Person&apos; objects&gt;, &apos;__doc__&apos;: None, &apos;__init__&apos;: &lt;function __init__ at 0x02C64630&gt;}
dir()返回的是对象属性的一个名字列表，__dict__返回的是一个字典，键是属性名，键值时相应的属性对象的数据值。
</code></pre><ul>
<li><code>C.__name__</code> 类C的名字</li>
<li><code>C.__doc__</code> 类C的文档字符串</li>
<li><code>C.__bases__</code> 类C的所有父类构成的元组</li>
<li><code>C.__dict__</code> 类C的属性</li>
<li><code>C.__module__</code> 类C定义所在的模块</li>
<li><code>C.__class__</code> 实例C对应的类</li>
</ul>
<p>-</p>
<pre><code>&gt;&gt;&gt; Person.__name__
&apos;Person&apos;
&gt;&gt;&gt; Person.__bases__
(&lt;type &apos;object&apos;&gt;,)
&gt;&gt;&gt; Person.__module__
&apos;__main__&apos;
&gt;&gt;&gt; Person.__class__
&lt;type &apos;type&apos;&gt;
</code></pre><p>注意：文档字符串不能被派生类继承。</p>
<h2 id="u5B9E_u4F8B_u5C5E_u6027VS_u7C7B_u5C5E_u6027"><a href="#u5B9E_u4F8B_u5C5E_u6027VS_u7C7B_u5C5E_u6027" class="headerlink" title="实例属性VS类属性"></a>实例属性VS类属性</h2><p>类属性是与类相关的数据值，与实例无关。静态成员是不会因为实例而改变它们的值。</p>
<h3 id="u8BBF_u95EE_u7C7B_u5C5E_u6027"><a href="#u8BBF_u95EE_u7C7B_u5C5E_u6027" class="headerlink" title="访问类属性"></a>访问类属性</h3><p>类属性可以通过类或实例访问的。</p>
<pre><code>&gt;&gt;&gt; class C(object):  # 定义类
        version = 1.2

&gt;&gt;&gt; c = C()  # 实例化
&gt;&gt;&gt; C.version  #通过类名来访问
1.2
&gt;&gt;&gt; c.version  # 通过实例来访问
1.2
</code></pre><h3 id="u7C7B_u5C5E_u6027_u7684_u66F4_u65B0"><a href="#u7C7B_u5C5E_u6027_u7684_u66F4_u65B0" class="headerlink" title="类属性的更新"></a>类属性的更新</h3><pre><code>&gt;&gt;&gt; C.version += 0.1 # 通过类来更新
&gt;&gt;&gt; C.version
1.3
&gt;&gt;&gt; c.version
1.3
&gt;&gt;&gt; c.version += 0.1 # 通过实例来更新
&gt;&gt;&gt; C.version
1.3
&gt;&gt;&gt; c.version
1.4
</code></pre><p>我们发现，通过类来更新类属性可以影响到类和实例的属性，而通过实例属性只能影响到实例属性，无法改变类属性，这是因为实例属性覆盖了对类属性的访问，而类属性仍在类域中。</p>
<pre><code>&gt;&gt;&gt; del c.version
&gt;&gt;&gt; c.version
1.3
&gt;&gt;&gt; C.version
1.3
</code></pre><p>我们删除以后，又恢复了之前的状态。如果我们同样创建一个新的实例属性，类属性不变。因为属性已存在于类字典<code>[__dict__]</code>中，通过赋值，将其加入到实例的<code>__dict__</code>中。</p>
<pre><code>&gt;&gt;&gt; class C(object):
        x = {&apos;Language1&apos;: &apos;C++&apos;}

&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.x
{&apos;Language1&apos;: &apos;C++&apos;}
&gt;&gt;&gt; c.x[&apos;Language2&apos;] = &apos;Python&apos; 通过实例来更新
&gt;&gt;&gt; c.x
{&apos;Language2&apos;: &apos;Python&apos;, &apos;Language1&apos;: &apos;C++&apos;}
&gt;&gt;&gt; C.x  # 生效了
{&apos;Language2&apos;: &apos;Python&apos;, &apos;Language1&apos;: &apos;C++&apos;}
</code></pre><h1 id="init___28_29_u6784_u9020_u5668"><a href="#init___28_29_u6784_u9020_u5668" class="headerlink" title="__init__()构造器"></a><code>__init__()</code>构造器</h1><p>当类被调用时，实例化的第一步是创建实例对象，一旦对象被创建，Python会检查是否实现<code>__init__()</code>方法，如果没有定义，对实例不会施加任何特别的操作，如果<code>__init__()</code>被实现，那么它将会被调用，调用类时，传进的参数都会传给它。类似于C++中的构造函数。</p>
<pre><code>&gt;&gt;&gt;Joe = Person(&apos;Joe&apos;, &apos;400-238-188&apos;)
&apos;Joe&apos;和&apos;400-238-188&apos;首先分别会传递给self.name和self.phone
</code></pre><p>注意：由于实例对象是自动在实例化调用后返回的。<code>__init__()</code>不应该返回任何对象(应为None)。如果返回非None的任何其他对象都会导致TypeError异常。</p>
<h1 id="del___28_29_u89E3_u6784_u5668"><a href="#del___28_29_u89E3_u6784_u5668" class="headerlink" title="__del__()解构器"></a><code>__del__()</code>解构器</h1><p>同样地，Python中有一个相应的特殊解构器<code>__del__()</code>。Python具有垃圾对象回收机制，这个函数直到该实例对象的引用都被清除掉后才被调用。类似于C++中的析构函数。</p>
<pre><code>&gt;&gt;&gt; class DelExmple(Person):
        def __init__(self):
        print &apos;initialized.&apos;
    def __del__(self):
        Person.__del__(self)
        print &apos;deleted.&apos;

&gt;&gt;&gt; ex1 = DelExmple()
initialized.
&gt;&gt;&gt; ex2 = ex1
&gt;&gt;&gt; ex3 = ex1
&gt;&gt;&gt; id(ex1), id(ex2), id(ex3) # 确定引用同意对象的三个别名
(46542416, 46542416, 46542416)
&gt;&gt;&gt; del ex1
&gt;&gt;&gt; del ex2
&gt;&gt;&gt; del ex3
deleted.
</code></pre><p>注意：不要在<code>__del__()</code>中干与实例无关的事情，尽量不要去显式地使用它。</p>
<h1 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h1><p>有时候，我们需要对一个已经定义好的类进行拓展或者修改，而不能影响到系统中使用此类的其他代码段，面向对象设计为我们提供了一个比较好的方法就是<strong>派生</strong>，派生的关系图类似于树，树的主干就相当于基类，各个分支就相当于子类，一个子类可以<em>继承</em>它的基类的任何属性。</p>
<pre><code>class Parent(object): # 定义父类
    &apos;Parent_class documentation string&apos; # 基类字符串文档
    def ParentMethod(self): 
        print &apos;calling parent method.&apos;

class Child(Parent): # 定义子类
    &apos;Child_class documentation string&apos; # 子类字符串文档
    def ChildtMethod(self): 
        print &apos;calling child method.&apos;

&gt;&gt;&gt; parent = Parent()
&gt;&gt;&gt; parent.ParentMethod()
calling parent method.
&gt;&gt;&gt; child = Child()
&gt;&gt;&gt; child.ChildMethod()
calling child method.
</code></pre><h2 id="u7EE7_u627F_u8986_u76D6_u65B9_u6CD5"><a href="#u7EE7_u627F_u8986_u76D6_u65B9_u6CD5" class="headerlink" title="继承覆盖方法"></a>继承覆盖方法</h2><p>我们可以在子类的代码实现中，编写和基类同名函数以实现对基类的方法的覆盖。</p>
<pre><code>def Parent(object):
    def __init__(self):
        print &quot;calling Parent&apos;s constructor.&quot;
def Child(Parent):
    def __init__(self):
        print &quot;calling Child&apos;s constructor.&quot;

&gt;&gt;&gt; parent = Parent()
calling Parent&apos;s constructor.
&gt;&gt;&gt; child = Child()
calling Child&apos;s constructor.
</code></pre><p>我们可以在子类的实现过程中调用基类的同名函数：</p>
<pre><code>def Parent(object):
    def __init__(self):
        print &quot;calling Parent&apos;s constructor.&quot;
def Child(Parent):
    def __init__(self):
        Parent.__init__(self)
        print &quot;calling Child&apos;s constructor.&quot;

&gt;&gt;&gt; child = Child()
calling Parent&apos;s constructor.
calling Child&apos;s constructor.
子类的__init__()方法首先调用基类的__init__()方法，然后再执行子类内部的__init__()方法。
</code></pre><p>还可以通过super()内建函数实现以上功能：</p>
<pre><code>def Parent(object):
    def __init__(self):
        print &quot;calling Parent&apos;s constructor.&quot;
def Child(Parent):
    def __init__(self):
        super(Child, self).__init__()
        print &quot;calling Child&apos;s constructor.&quot;

&gt;&gt;&gt; child = Child()
calling Parent&apos;s constructor.
calling Child&apos;s constructor.
</code></pre><p>使用super()函数可以使你无需提供基类，意味着如果你改变了类继承关系，只需修改一行代码而不必去查找修改所有与之相关的类的名字。</p>
<h2 id="u591A_u91CD_u7EE7_u627F"><a href="#u591A_u91CD_u7EE7_u627F" class="headerlink" title="多重继承"></a>多重继承</h2><p>Python允许子类继承多个基类，即多重继承。</p>
<pre><code>class Parent1(object): # 定义父类1
    &apos;Parent_class documentation string&apos; # 基类字符串文档
    def ParentMethod1(self): 
        print &apos;calling parent method.&apos;

class Parent2(object): # 定义父类2
    &apos;Parent_class documentation string&apos; # 基类字符串文档
    def ParentMethod2(self): 
        print &apos;calling parent method.&apos;

class Child(Parent1， Parent2): # 定义子类
    &apos;Child_class documentation string&apos; # 子类字符串文档
    def ChildtMethod(self): 
        print &apos;calling child method.&apos;
</code></pre><h3 id="u65B9_u6CD5_u89E3_u91CA_u987A_u5E8F"><a href="#u65B9_u6CD5_u89E3_u91CA_u987A_u5E8F" class="headerlink" title="方法解释顺序"></a>方法解释顺序</h3><p>在Python2.2以前的版本中采用“深度优先，从左到右搜索”。而在新的版本中(Python2.3以后)使用广度优先的算法。是因为类，类型和内建类型的子类的修改，深度优先的算法不再适合新的数据结构，在多重继承中，新式类使用此算法会引起“菱形效应”。</p>
<pre><code># 经典类

B    C
  D

class B:
    pass
class C:
    def __init__(self):
        print &apos;The default constructor.&apos;
class D(B, D):
    pass

&gt;&gt;&gt; d = D()
The default constructor.

# 新式类

  A(object)
B    C
  D

class B(object):
    pass
class C(object):
    def __init__(self):
        print &apos;The default constructor.&apos;
class D(B, D):
    pass
</code></pre><p>由于在新式类中的类声明加了(object)，导致继承结构变成了一个菱形，如果我们使用深度优先的算法，当实例化D时，不再得到<code>C.__init__()</code>的结果，而是得到<code>object.__init__()</code>。经典类继续沿用老式算法，新式类使用新式算法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于学习过C++或者Java等高级语言的人来说，面向对象可能不是那么陌生，但是没有接触过编程语言或只是简单地了解C语言的人可能不是很了解面向对象。C语言是一种面向过程的设计语言，而C++是一门面向对象的编程语言，面向对象的设计核心更注重于人类的思维，即我们有必要了解下这一编]]>
    </summary>
    
      <category term="类" scheme="http://dsljlbaby.github.io/tags/%E7%B1%BB/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之模块]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%97/"/>
    <id>http://dsljlbaby.github.io/2016/02/10/Python学习笔记之模块/</id>
    <published>2016-02-10T07:15:57.000Z</published>
    <updated>2016-02-13T07:39:41.754Z</updated>
    <content type="html"><![CDATA[<p>本篇主要介绍Python模块和如何将模块导入编程环境中，模块是用来组织代码的方法。</p>
<h1 id="u6A21_u5757_28module_29"><a href="#u6A21_u5757_28module_29" class="headerlink" title="模块(module)"></a>模块(module)</h1><p>模块支持从逻辑上组织Python代码。当程序员编写的代码量变得相当大的时候，就可以把代码分成一些有组织的代码段，彼此之间可以交互。可以是一个包含数据成员和方法的类，也可以是一组相关但彼此独立的操作函数。这些代码之间是共享的。把其他模块中属性附加到你的模块中的操作叫做导入(import)，那些自我包含且有组织的代码片段称为模块(module)。</p>
<h1 id="u547D_u540D_u7A7A_u95F4_28namespace_29"><a href="#u547D_u540D_u7A7A_u95F4_28namespace_29" class="headerlink" title="命名空间(namespace)"></a>命名空间(namespace)</h1><p>命名空间(namespace)就是一个从名称到对象的关系映射集合。</p>
<p>在程序执行期间有三个活动的命名空间，分别为局部命名空间(local namespace)、全局命名空间(global namespace)、内建名称空间(build-in namespace)。</p>
<p>我们可以使用globals()和locals()内建函数判断一个名字属于哪一个命名空间。</p>
<p>globals()和locals()内建函数分别返回调用者全局和局部命名空间的字典。</p>
<h2 id="u547D_u540D_u7A7A_u95F4_u4E0E_u53D8_u91CF_u4F5C_u7528_u57DF"><a href="#u547D_u540D_u7A7A_u95F4_u4E0E_u53D8_u91CF_u4F5C_u7528_u57DF" class="headerlink" title="命名空间与变量作用域"></a>命名空间与变量作用域</h2><p>变量作用域除了指出名字与对象间的映射关系，还指出了从用户代码的哪些物理位置可以访问到这些名字。</p>
<p><em>在程序的执行过程中，局部命名空间和作用域会随着函数调用而变化。</em></p>
<h2 id="u540D_u79F0_u7684_u67E5_u627E"><a href="#u540D_u79F0_u7684_u67E5_u627E" class="headerlink" title="名称的查找"></a>名称的查找</h2><p>当函数、变量等信息发生重名时，Python会按照”local namespace -&gt; global namespace -&gt; build-in namespace”的顺序进行搜索用户所需元素，并且以第一个找到此元素的namespace为准。</p>
<h1 id="u8DEF_u5F84_u641C_u7D22"><a href="#u8DEF_u5F84_u641C_u7D22" class="headerlink" title="路径搜索"></a>路径搜索</h1><p>在模块的导入时，需要一个“路径搜索”的过程，即在文件系统“预定义区域”中查找要导入的模块，如果没有找到，将会返回错误ImportError。</p>
<p>搜索路径是指待查找的一组目录地址。<br>路径搜索是指查找某个文件的操作。</p>
<h1 id="u5BFC_u5165_u6A21_u5757"><a href="#u5BFC_u5165_u6A21_u5757" class="headerlink" title="导入模块"></a>导入模块</h1><ul>
<li><p>使用import语句导入模块。</p>
<pre><code>   import module  # 单个模块导入
import module1, module2.... # 多个模块导入
</code></pre></li>
<li><p>使用from-import语句导入模块。</p>
<pre><code>from module import name
</code></pre></li>
<li><p>拓展import语句(as)</p>
<pre><code>from module import name as yourname
可以通过这种方法来替换模块中的某个对象的名称
</code></pre></li>
</ul>
<p>注意： import语句导入模块的方法是加载这一模块中的全部对象到你的程序中，而from-import语句简单地导入你所要使用的具体的对象，比较节省内存。</p>
<h1 id="u5BFC_u5165_u987A_u5E8F"><a href="#u5BFC_u5165_u987A_u5E8F" class="headerlink" title="导入顺序"></a>导入顺序</h1><p>建议按照以下顺序进行导入相关模块。</p>
<ol>
<li>Python标准库模块</li>
<li>Python第三方模块</li>
<li>应用程序自定义模块</li>
</ol>
<h1 id="u5173_u4E8E__future"><a href="#u5173_u4E8E__future" class="headerlink" title="关于__future__"></a>关于<code>__future__</code></h1><p>由于改进、新特性和当前特性增强，某些变化会影响到当前功能，为了让Python程序员为新事物做好准备，Python实现了<strong>future</strong>指令。</p>
<p>可以使用from-import语句导入新特性。</p>
<pre><code>from __future__ import new_feature
</code></pre><h1 id="reload_28_29"><a href="#reload_28_29" class="headerlink" title="reload()"></a>reload()</h1><p>reload()内建函数可以重新导入一个已经导入的模块。</p>
<pre><code>reload(module)
</code></pre><p>这个方法是模块的全部导入以及模块必须成功导入。函数的参数是模块名称。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇主要介绍Python模块和如何将模块导入编程环境中，模块是用来组织代码的方法。</p>
<h1 id="u6A21_u5757_28module_29"><a href="#u6A21_u5757_28module_29" class="headerlink" titl]]>
    </summary>
    
      <category term="模块" scheme="http://dsljlbaby.github.io/tags/%E6%A8%A1%E5%9D%97/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之迭代器和生成器]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://dsljlbaby.github.io/2016/02/10/Python学习笔记之迭代器和生成器/</id>
    <published>2016-02-10T05:28:11.000Z</published>
    <updated>2016-02-10T07:07:31.444Z</updated>
    <content type="html"><![CDATA[<h1 id="u8FED_u4EE3_u5668"><a href="#u8FED_u4EE3_u5668" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是拥有一个next()方法的对象。当你需要获取一个对象的下一项时，可以通过调用迭代器的next()方法获得它，当所有的条目取出后，就会引发一个StopIteration异常来说明迭代结束。</p>
<p>我们可以使用迭代器不但可以访问序列对象，也可以访问类序列对象(例如一个字典的键或值、一个文件的行)</p>
<h2 id="u8FED_u4EE3_u5668_u7684_u521B_u5EFA"><a href="#u8FED_u4EE3_u5668_u7684_u521B_u5EFA" class="headerlink" title="迭代器的创建"></a>迭代器的创建</h2><p>对一个对象调用iter()方法来获取它的迭代器。</p>
<pre><code>iter(obj)
传递一个参数给iter()，首先，它会检测这个参数是否为序列，如果是，它就会根据索引一直迭代到序列结束。
iter(func, sentinel)
如果使用这种方法，我们需要传递两个参数，它会反复地调用func，直到迭代器的某一值等于sentinel。
</code></pre><h2 id="u4E0D_u53EF_u53D8_u5BF9_u8C61_u7684_u8FED_u4EE3"><a href="#u4E0D_u53EF_u53D8_u5BF9_u8C61_u7684_u8FED_u4EE3" class="headerlink" title="不可变对象的迭代"></a>不可变对象的迭代</h2><p>一个序列的迭代器只是记录你当前到达第几个元素，如果你在迭代过程中改变了元素，更新会立即反应到你所迭代的条目上，就会引发错误。</p>
<p>在迭代字典的键时，是绝对不能改变这个字典的，但是使用字典的keys()方法是可以的，因为它返回一个独立于字典的列表。</p>
<h2 id="for_u5FAA_u73AF"><a href="#for_u5FAA_u73AF" class="headerlink" title="for循环"></a>for循环</h2><p>for语句会自动调用迭代器的next()方法并捕获异常。</p>
<p>使用迭代器做for循环的代码与使用序列条目几乎一样，在大多数情况下，我们无法分辨迭代是一个序列还是迭代器。</p>
<h2 id="u8FED_u4EE3_u7684_u64CD_u4F5C"><a href="#u8FED_u4EE3_u7684_u64CD_u4F5C" class="headerlink" title="迭代的操作"></a>迭代的操作</h2><p>同过几个常见的迭代操作来增强对迭代的理解。</p>
<h3 id="u624B_u52A8_u8FED_u4EE3"><a href="#u624B_u52A8_u8FED_u4EE3" class="headerlink" title="手动迭代"></a>手动迭代</h3><p>我们在处理某个可迭代对象中的元素，但由于某种原因不能使用for循环，可以手动使用next()方法。</p>
<pre><code>&gt;&gt;&gt; items = [1, 2, 3]
&gt;&gt;&gt; it = iter(items)
&gt;&gt;&gt; next(it)
1
&gt;&gt;&gt; next(it)
2
&gt;&gt;&gt; next(it)
3
&gt;&gt;&gt; next(it)

Traceback (most recent call last):
    File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt;
    next(it)
StopIteration
</code></pre><h3 id="u53CD_u5411_u8FED_u4EE3"><a href="#u53CD_u5411_u8FED_u4EE3" class="headerlink" title="反向迭代"></a>反向迭代</h3><p>使用内建函数reversed()实现反向迭代。</p>
<pre><code>&gt;&gt;&gt; for item in reversed([1, 2, 3]):
        print item
3
2
1
</code></pre><h3 id="u7D22_u5F15-_u503C_u5BF9_u7684_u8FED_u4EE3"><a href="#u7D22_u5F15-_u503C_u5BF9_u7684_u8FED_u4EE3" class="headerlink" title="索引-值对的迭代"></a>索引-值对的迭代</h3><p>使用内建函数enumerate()实现索引-值对的迭代。</p>
<pre><code>&gt;&gt;&gt; my_list = [&apos;Python&apos;, &apos;C++&apos;, &apos;C&apos;, &apos;Java&apos;, &apos;PHP&apos;, &apos;R&apos;]
&gt;&gt;&gt; for index, value in enumerate(my_list):
    print index, value

0 Python
1 C++
2 C
3 Java
4 PHP
5 R
</code></pre><h3 id="u8FED_u4EE3_u591A_u4E2A_u5E8F_u5217"><a href="#u8FED_u4EE3_u591A_u4E2A_u5E8F_u5217" class="headerlink" title="迭代多个序列"></a>迭代多个序列</h3><p>如果我们想要迭代的元素在多个序列中，就需要同时迭代多个序列，使用zip()方法实现。zip()创建一个迭代器，该迭代器产生出元组(x, y)，其中x取自序列a，y取自于序列b，整个迭代的长度和其中最短的序列长度相同。</p>
<pre><code>&gt;&gt;&gt; a = [0, 1, 2, 3]
&gt;&gt;&gt; b = [&apos;Python&apos;, &apos;C++&apos;, &apos;Java&apos;, &apos;PHP&apos;, &apos;C&apos;, &apos;R&apos;]
&gt;&gt;&gt; for i in zip(a, b):
    print i

(0, &apos;Python&apos;)
(1, &apos;C++&apos;)
(2, &apos;Java&apos;)
(3, &apos;PHP&apos;)
</code></pre><h2 id="u8FED_u4EE3_u5668_u7684_u4F5C_u7528"><a href="#u8FED_u4EE3_u5668_u7684_u4F5C_u7528" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><ul>
<li>提供了可拓展的迭代器接口；</li>
<li>对列表迭代带来了性能上的增强；</li>
<li>在字典迭代中性能提升；</li>
<li>创建真正的迭代接口，而不是原来的随即对象访问；</li>
<li>与所有已经存在的用户定义的类型以及拓展的模拟序列和映射的对象向后兼容；</li>
<li>迭代非序列集合时，创建更简洁可读的代码。</li>
</ul>
<h1 id="u751F_u6210_u5668"><a href="#u751F_u6210_u5668" class="headerlink" title="生成器"></a>生成器</h1><p>生成器是列表解析的一个拓展。</p>
<p>生成器是一个带有yield语句的函数，允许你返回一个值，然后“暂停”代码的执行，稍后恢复。</p>
<p>生成器在每次计算出一个条目后，把这个条目“yield(生成)”出来，生成器表达式使用了‘延迟计算’，节省了内存。</p>
<pre><code>列表解析：
[expr for iter_var in iterable if cond_expr]
生成器表达式：
(expr for iter_var in iterable if cond_expr)
</code></pre><p>函数中只要出现了yield语句就会将其转变成一个生成器，与普通函数不同的是，生成器只会在响应迭代操作时才运行。</p>
<p>使用生成器创建新的迭代模式：</p>
<pre><code>def frange(start, stop, increment):
    &apos;create a new range() about float number.&apos;
    x = start
    while x &lt; stop:
        yield x
        x += increment
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u8FED_u4EE3_u5668"><a href="#u8FED_u4EE3_u5668" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是拥有一个next()方法的对象。当你需要获取一个对象的下一项时，可以]]>
    </summary>
    
      <category term="生成器" scheme="http://dsljlbaby.github.io/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
      <category term="迭代器" scheme="http://dsljlbaby.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之文件]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%96%87%E4%BB%B6/"/>
    <id>http://dsljlbaby.github.io/2016/02/10/Python学习笔记之文件/</id>
    <published>2016-02-10T03:40:31.000Z</published>
    <updated>2016-02-10T05:25:57.000Z</updated>
    <content type="html"><![CDATA[<p>我们在平时的工作或者学习过程中，需要对大量的文件进行处理，如果我们可以学习一门脚本语言，能够有效的处理文件，那将对我们的工作是一个很大的帮助。在Python的基本操作中，提供了一些关于文件的操作。</p>
<h1 id="u6587_u4EF6_u5BF9_u8C61_u7684_u64CD_u4F5C"><a href="#u6587_u4EF6_u5BF9_u8C61_u7684_u64CD_u4F5C" class="headerlink" title="文件对象的操作"></a>文件对象的操作</h1><ul>
<li>使用open()或者file()函数打开文件。</li>
<li>使用file.read()读取文件。</li>
<li>使用file.readline()读取文件的一行相关信息。</li>
<li>使用file.write()进行写入文件。</li>
<li>使用file.writelines(seq)向文件写入字符串序列seq。</li>
<li>使用file.close()关闭文件。</li>
<li>使用file.tell()返回当前在文件中的位置。</li>
<li>使用file.seek(off, where=0)在文件中移动指针，从where偏移off字节。</li>
</ul>
<h1 id="u6587_u4EF6_u5BF9_u8C61_u7684_u8BBF_u95EE_u6A21_u5F0F"><a href="#u6587_u4EF6_u5BF9_u8C61_u7684_u8BBF_u95EE_u6A21_u5F0F" class="headerlink" title="文件对象的访问模式"></a>文件对象的访问模式</h1><ul>
<li>r 以读方式打开</li>
<li>w 以写方式打开</li>
<li>a 以追加模式打开</li>
<li>rU 以读方式打开，同时提供通用换行符</li>
<li>r+、w+、a+ 以读写模式打开</li>
<li>rb 以二进制读模式打开</li>
<li>wb 以二进制写模式打开</li>
<li>ab 以二进制追加模式打开</li>
</ul>
<h1 id="u6587_u4EF6_u5C5E_u6027"><a href="#u6587_u4EF6_u5C5E_u6027" class="headerlink" title="文件属性"></a>文件属性</h1><ul>
<li>file.closed 返回True表示文件已经关闭</li>
<li>file.encoding 文件所使用的编码</li>
<li>file.name 文件名</li>
<li>file.mode 文件打开时使用的访问模式</li>
</ul>
<h1 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h1><p>对于文件系统的访问大多通过Python的os模块实现的，我们要熟练地掌握这一模块。</p>
<h1 id="u8BFB_u5199_u6587_u672C_u6570_u636E"><a href="#u8BFB_u5199_u6587_u672C_u6570_u636E" class="headerlink" title="读写文本数据"></a>读写文本数据</h1><p>使用open()函数配合r模式读取文本文件的内容。</p>
<pre><code>with open(&apos;filename.txt&apos;,&apos;r&apos;) as f:
    data = f.read()
</code></pre><p>使用open()函数配合w模式对文本文件进行写入。</p>
<pre><code>with open(&apos;filename.txt&apos;,&apos;w&apos;) as f:
    f.write(text)
</code></pre><p>使用open()函数配合a模式对文本文件进行追加。</p>
<pre><code>with open(&apos;filename.txt&apos;,&apos;a&apos;) as f:
    f.write(text)
</code></pre><p>注意：open()函数的默认模式是’r’.在示例中采用了with语句，这会为使用的文件创建一个上下文模式，当程序的控制流程离开with语句块后，文件自动关闭。如果是普通的文件操作模式，记得手动关闭文件。</p>
<pre><code>f = open(&apos;filename.txt&apos;,&apos;r&apos;)
data = f.read()
f.close()
</code></pre><h1 id="u8BFB_u5199_u4E8C_u8FDB_u5236_u6570_u636E"><a href="#u8BFB_u5199_u4E8C_u8FDB_u5236_u6570_u636E" class="headerlink" title="读写二进制数据"></a>读写二进制数据</h1><p>使用open()函数的rb或者wb实现对二进制数据的读或写。</p>
<pre><code>with open(&apos;filename.bin&apos;,&apos;rb&apos;) as f:
    data = f.read()
    f.write(b&apos;Hello World&apos;)
</code></pre><p>在读取或者写入二进制数据时，所有的数据是以字节串的形式操作，而不是文本字符串。</p>
<p>如果要在二进制文件中读取或者写入文本内容，要确保进行编码或者解码操作。</p>
<pre><code>with open(&apos;filename.bin&apos;,&apos;rb&apos;) as f:
    data = f.read(16)
    text = data.decode(&apos;utf-8&apos;)

with open(&apos;filename.bin&apos;,&apos;rb&apos;) as f:
    text = &apos;Hello World&apos;
    f.write(text.encode(&apos;utf-8&apos;))
</code></pre><h1 id="u4E0D_u5B58_u5728_u7684_u6587_u4EF6_u7684_u64CD_u4F5C"><a href="#u4E0D_u5B58_u5728_u7684_u6587_u4EF6_u7684_u64CD_u4F5C" class="headerlink" title="不存在的文件的操作"></a>不存在的文件的操作</h1><p>使用x模式(Python3中对open()函数的拓展)来代替w模式对一个不存在文件系统的文件操作。</p>
<pre><code>with open(&apos;filename.txt&apos;,&apos;xt&apos;) as f:
    f.write(&apos;Hello\n&apos;)
</code></pre><p>本节重点在于os模块的使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们在平时的工作或者学习过程中，需要对大量的文件进行处理，如果我们可以学习一门脚本语言，能够有效的处理文件，那将对我们的工作是一个很大的帮助。在Python的基本操作中，提供了一些关于文件的操作。</p>
<h1 id="u6587_u4EF6_u5BF9_u8C61_u7]]>
    </summary>
    
      <category term="文件" scheme="http://dsljlbaby.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之闭包]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/05/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://dsljlbaby.github.io/2016/02/05/Python学习笔记之闭包/</id>
    <published>2016-02-05T08:12:42.000Z</published>
    <updated>2016-02-05T10:04:13.950Z</updated>
    <content type="html"><![CDATA[<p>闭包是函数式编程的重要语法结构，Python是以函数对象为基础的，为闭包这一语法结构提供支持。在学习的起初，我也不是很理解闭包，经过查询资料和阅读他人博客后，对闭包有了一点见解，把它写出来，需要的朋友可以参考，如果发现不足之处，希望大家指出。</p>
<h1 id="u4EC0_u4E48_u662F_u95ED_u5305"><a href="#u4EC0_u4E48_u662F_u95ED_u5305" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包(Closure)是词法闭包(Lexical Closure)的简称，是引用了自由变量(或者称为环境变量)的函数。这个被引用的自然变量将和这个函数一同存在，即使离开了创造它的环境也不例外。</p>
<p>初步理解：<strong>闭包 = 函数 + 自然变量</strong></p>
<p>那么这里的函数具体是指什么呢？自然变量又是什么呢？这两个概念先放在这个，等到我们有了一定的基础后理解它就比较容易啦。</p>
<h1 id="u5185_u5D4C_u51FD_u6570"><a href="#u5185_u5D4C_u51FD_u6570" class="headerlink" title="内嵌函数"></a>内嵌函数</h1><p>要理解闭包，我们得知道内嵌函数，那么内嵌函数又是什么呢？</p>
<p>内嵌函数是指在一个函数体内创建另一个函数。新创建的函数称为<strong>内嵌函数</strong>，原来的函数被称为<strong>外部函数</strong></p>
<pre><code>def line_conf():
    def line(x):
        return 2*x + 1
    print line(5)
</code></pre><p>在上面的函数中，line_conf()称为外部函数，line()称为内嵌函数。内嵌函数存在于外部函数体内，<em>除了外部函数体内，其他地方都不能对其调用。</em></p>
<h1 id="Python_u4E2D_u7684_u547D_u540D_u7A7A_u95F4_28namespace_29"><a href="#Python_u4E2D_u7684_u547D_u540D_u7A7A_u95F4_28namespace_29" class="headerlink" title="Python中的命名空间(namespace)"></a>Python中的命名空间(namespace)</h1><p>在真正地认识闭包之前，我们简单了解一下Python的namespace，有助于我们理解后面的变量。</p>
<p>Python中通过namespace提供重名函数、变量等信息的识别。共有三种namespace,分别为：</p>
<ul>
<li>local namespace: 作用范围为当前函数或类方法。</li>
<li>global namespace: 作用范围为当前模块</li>
<li>build-in namespace: 作用范围为所有模块</li>
</ul>
<p>当函数、变量等信息发生重名时，Python会按照”local namespace -&gt; global namespace -&gt; build-in namespace”的顺序进行搜索用户所需元素，并且以第一个找到此元素的namespace为准。</p>
<p>Python中的内建函数locals()和globals()可以查看不同namespace中定义的元素。</p>
<h1 id="u5185_u5D4C_u51FD_u6570_u7684_u6DF1_u5165"><a href="#u5185_u5D4C_u51FD_u6570_u7684_u6DF1_u5165" class="headerlink" title="内嵌函数的深入"></a>内嵌函数的深入</h1><p>函数对象的作用域与def所在的层次相同，函数是一个对象，可以作为某个函数的返回结果。</p>
<p>下面这段代码是接近闭包的一个构造：</p>
<pre><code># eg1
&gt;&gt;&gt; def line_conf():
        def line(x):
            return 2*x + 1
        return line

&gt;&gt;&gt; my_line = line_conf()
&gt;&gt;&gt; my_line(5)
11
</code></pre><h1 id="u95ED_u5305_u7684_u521B_u5EFA"><a href="#u95ED_u5305_u7684_u521B_u5EFA" class="headerlink" title="闭包的创建"></a>闭包的创建</h1><pre><code># eg2
&gt;&gt;&gt; def line_conf():
        &apos;this is ture closure.&apos;
        b = 15
        def line(x):
            return 2*x + 1
        return line

&gt;&gt;&gt; my_line = line_conf()
&gt;&gt;&gt; my_line(3)
7
</code></pre><p>通过对比eg2和eg1的代码发现,在函数line_conf中，eg2比eg1多了一个变量。其实，这个变量就是闭包中一个重要的组成：<strong>自由变量</strong>。</p>
<p>自由变量：定义在外部函数内的，但由内嵌函数引用或使用的变量。</p>
<p>即<strong>闭包 = 自由变量 + 内嵌函数</strong></p>
<p>重新审视下上面的代码，函数line_conf()是外部函数，变量b是自由变量，函数line()是内嵌函数，只能在外部函数line_conf()体内调用函数line()。line()函数访问了non_local的自由变量”b”,自由变量”b”并没有随着外部函数的退出而销毁，反而是生命周期得到了延长。</p>
<h1 id="closure_u5C5E_u6027"><a href="#closure_u5C5E_u6027" class="headerlink" title="closure属性"></a><strong>closure</strong>属性</h1><p>在Python中，我们可以通过函数对象的<strong>closure</strong>属性查看闭包的一些细节，也可以理解为什么自由变量没有随着外部函数的退出而销毁。</p>
<pre><code>&gt;&gt;&gt; def line_conf():
    b =15
    def line(x):
        return 2 * x + b
    return line
&gt;&gt;&gt; my_line = line_conf()
&gt;&gt;&gt; print my_line.__closure__
(&lt;cell at 0x02AC2FF0: int object at 0x0247A230&gt;,)
&gt;&gt;&gt; print my_line.__closure__[0].cell_contents
15
</code></pre><p>通过调试结果看出，<strong>closure</strong>里包含一个元组，这个元组的每个元素都是cell类型的对象，第一个cell包含的就是我们创建闭包时的自由变量b的取值。</p>
<h1 id="u95ED_u5305_u7684_u603B_u7ED3"><a href="#u95ED_u5305_u7684_u603B_u7ED3" class="headerlink" title="闭包的总结"></a>闭包的总结</h1><p>闭包是函数式编程的重要语法结构，函数式编程和面向过程以及面向对象编程一样都是编程范式，面向过程编程中的<strong>函数</strong>，面向过程编程中的<strong>对象</strong>和<strong>闭包</strong>的相同点是：以某种逻辑方式组织代码，实现代码的可重复性使用。</p>
<p>闭包的特性：</p>
<ul>
<li>闭包函数必须有内嵌函数</li>
<li>内嵌函数需要引用外部函数中的变量</li>
<li>闭包函数必须返回内嵌函数</li>
</ul>
<p>注意：我们在写闭包时，不要在内嵌函数中对自由变量进行赋值操作，至少在Python2.x中不可以。会出现UnbundLocalError错误。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>闭包是函数式编程的重要语法结构，Python是以函数对象为基础的，为闭包这一语法结构提供支持。在学习的起初，我也不是很理解闭包，经过查询资料和阅读他人博客后，对闭包有了一点见解，把它写出来，需要的朋友可以参考，如果发现不足之处，希望大家指出。</p>
<h1 id="u4E]]>
    </summary>
    
      <category term="闭包" scheme="http://dsljlbaby.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之函数]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/05/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://dsljlbaby.github.io/2016/02/05/Python学习笔记之函数/</id>
    <published>2016-02-05T02:51:08.000Z</published>
    <updated>2016-02-05T09:47:27.470Z</updated>
    <content type="html"><![CDATA[<p>函数就是对程序逻辑进行结构化或过程化的一种编程方法。函数可以将我们编写的代码进行格式化，便于管理和理解，以及节约空间，减少代码的重复性。</p>
<h1 id="u51FD_u6570_u7684_u5B9A_u4E49"><a href="#u51FD_u6570_u7684_u5B9A_u4E49" class="headerlink" title="函数的定义"></a>函数的定义</h1><p>函数就是对程序逻辑进行结构化或过程化的一种编程方法。和我们数学中学习的函数基本相似。编程语言中函数的初现，有利于我们将整块代码巧妙地隔离成易于管理的小块，将重复代码放进函数中而不是进行大量的拷贝，节省空间，有助于一致性。</p>
<h1 id="u51FD_u6570_VS__u8FC7_u7A0B"><a href="#u51FD_u6570_VS__u8FC7_u7A0B" class="headerlink" title="函数 VS 过程"></a>函数 VS 过程</h1><p>函数和过程都是可以被调用的实体。函数相当于一个黑盒子，给予输入(或者不带任何输入)，经过一定的处理，最后可以返回结果。过程则是简单、特殊、无返回值的函数。但是在Python中，过程等价于函数，解释器会隐式地返回默认值None。</p>
<h1 id="u51FD_u6570_u7684_u521B_u5EFA"><a href="#u51FD_u6570_u7684_u521B_u5EFA" class="headerlink" title="函数的创建"></a>函数的创建</h1><p>在Python中，函数使用def语句进行创建。</p>
<pre><code>def function_name(arguments):
    &apos;function_documents_string&apos; # 函数的描述，可选，建议书写，可使代码阅读者更好地理解程序
    function_body_suite
</code></pre><h2 id="u51FD_u6570_u58F0_u660E_u4E0E_u5B9A_u4E49"><a href="#u51FD_u6570_u58F0_u660E_u4E0E_u5B9A_u4E49" class="headerlink" title="函数声明与定义"></a>函数声明与定义</h2><p>类似C、C++等编程语言中，函数声明和函数的定义是区分的，但在Python中，两者视为一体。函数的声明包括提供函数名、参数名、参数类型。函数的定义包括函数声明部分，并且还有函数的具体代码。</p>
<h2 id="u51FD_u6570_u5C5E_u6027"><a href="#u51FD_u6570_u5C5E_u6027" class="headerlink" title="函数属性"></a>函数属性</h2><p>函数属性是Python的一个使用”.”属性标志并拥有<em>命名空间</em>的特性。我们可以通过’.’来访问函数的属性。</p>
<pre><code>&gt;&gt;&gt; def func():
    &apos;func() -- proper created doc string.&apos;
    pass

&gt;&gt;&gt; func.__doc__
&apos;func() -- proper created doc string.&apos;
&gt;&gt;&gt; func.__name__
&apos;func&apos;
</code></pre><h2 id="u51FD_u6570_u7684_u8C03_u7528_u4E0E_u5F15_u7528"><a href="#u51FD_u6570_u7684_u8C03_u7528_u4E0E_u5F15_u7528" class="headerlink" title="函数的调用与引用"></a>函数的调用与引用</h2><p>在Python中，函数是可以被<em>引用</em>(访问或者以其他变量作为其别名，指向同一块内存地址)的。函数的调用与引用最简单的区别就是。将一个函数名赋值给另外一个变量就是函数的引用，将一个函数赋值给另外一个变量就是函数的调用。</p>
<pre><code>&gt;&gt;&gt; def func1():
print &apos;in func1().&apos;


&gt;&gt;&gt; func2 = func1 # 函数引用
&gt;&gt;&gt; func3 = func1() # 函数调用
in func1().
&gt;&gt;&gt; func2()
in func1().
&gt;&gt;&gt; func1()
in func1().
&gt;&gt;&gt; func1
&lt;function func1 at 0x02B044F0&gt;
&gt;&gt;&gt; func2
&lt;function func1 at 0x02B044F0&gt;
</code></pre><h2 id="u51FD_u6570_u53C2_u6570"><a href="#u51FD_u6570_u53C2_u6570" class="headerlink" title="函数参数"></a>函数参数</h2><p>Python函数的参数集合包括了无参数、带参数、默认参数、关键字参数以及可变长度的参数。</p>
<h3 id="u65E0_u53C2_u6570"><a href="#u65E0_u53C2_u6570" class="headerlink" title="无参数"></a>无参数</h3><p>Python函数中没有任何参数的传入，在函数调用时无需传入。</p>
<pre><code>&gt;&gt;&gt; def func1():
    print &apos;Hello World.&apos;

&gt;&gt;&gt; func1()
Hello World.
</code></pre><h3 id="u5E26_u53C2_u6570"><a href="#u5E26_u53C2_u6570" class="headerlink" title="带参数"></a>带参数</h3><p>在调用函数时，必须传入参数且个数与定义函数的参数个数相等。</p>
<pre><code>&gt;&gt;&gt; def func2(arg):
    print &apos;Hello &apos;, arg

&gt;&gt;&gt; func2(&apos;World&apos;)
Hello  World
</code></pre><h3 id="u9ED8_u8BA4_u53C2_u6570"><a href="#u9ED8_u8BA4_u53C2_u6570" class="headerlink" title="默认参数"></a>默认参数</h3><p>默认参数是指函数的定义时已经给出参数值。在调用函数时，如果没有提供参数将会按照默认参数值，如果重新给出，则按给出的参数值传入。</p>
<pre><code>&gt;&gt;&gt; def func3(arg = &apos;World&apos;):
    print &apos;Hello &apos;, arg

&gt;&gt;&gt; func3()
Hello  World
&gt;&gt;&gt; func3(&apos;Python&apos;)
Hello  Python
</code></pre><h3 id="u5173_u952E_u5B57_u53C2_u6570"><a href="#u5173_u952E_u5B57_u53C2_u6570" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是指一顺序或者不按顺序传入，但是带有参数列表中曾定义过的关键字。</p>
<pre><code>&gt;&gt;&gt; def cal(a，b = 4):
    print &apos;%d + %d = %d&apos; % (a, b, a + b)

&gt;&gt;&gt; cal(2，3)
2 + 3 = 5
&gt;&gt;&gt; cal(3)
3 + 4 = 7
&gt;&gt;&gt; cal(a = 2，b = 8)
2 + 8 = 10
</code></pre><p>注意：所有必须参数(在函数定义时，无默认值传入的参数)都要在默认参数之前。</p>
<h3 id="u53EF_u53D8_u957F_u5EA6_u7684_u53C2_u6570"><a href="#u53EF_u53D8_u957F_u5EA6_u7684_u53C2_u6570" class="headerlink" title="可变长度的参数"></a>可变长度的参数</h3><p>有时，我们可能需要用函数处理可变数量的参数，这时就需要可变长度的参数列表。变长的参数在函数声明时并不是显式命名的。在函数调用中使用<em>和*</em>符号来指定元组和字典的元素作为非关键字以及关键字参数的方法。</p>
<h4 id="u975E_u5173_u952E_u5B57_u53EF_u53D8_u957F_u53C2_u6570_28_u5143_u7EC4_29"><a href="#u975E_u5173_u952E_u5B57_u53EF_u53D8_u957F_u53C2_u6570_28_u5143_u7EC4_29" class="headerlink" title="非关键字可变长参数(元组)"></a>非关键字可变长参数(元组)</h4><p>当函数调用时，所有的形参都将值赋给了在函数声明中相对应的局部变量，剩下的非关键字参数按顺序插入到一个元组中便于访问。元组保存了所有传递给函数的”额外”的参数，如果没有给出额外的参数，元组将为空。</p>
<p>可变长的参数元组必须在默认和关键字参数之后。</p>
<pre><code>def function_name(formal_args, *vargs_tuple):
    &apos;function_documentation_string&apos;
    function_body_suite

# eg
&gt;&gt;&gt; def tupleVarArgs(arg1, arg2 = &apos;default&apos;, *theRest):
    &apos;display regular args and non_keyword variable args&apos;
    print &apos;formal arg 1:&apos;, arg1
    print &apos;formal arg 2:&apos;, arg2
    for eachXtrArg in theRest:
        print &apos;another arg:&apos;, eachXtrArg

&gt;&gt;&gt; tupleVarArgs(&apos;abc&apos;)
formal arg 1: abc
formal arg 2: default
&gt;&gt;&gt; tupleVarArgs(&apos;abc&apos;, 123, &apos;xyz&apos;, 37.2)
formal arg 1: abc
formal arg 2: 123
another arg: xyz
another arg: 37.2
</code></pre><h4 id="u5173_u952E_u5B57_u53EF_u53D8_u957F_u53C2_u6570_28_u5B57_u5178_29"><a href="#u5173_u952E_u5B57_u53EF_u53D8_u957F_u53C2_u6570_28_u5B57_u5178_29" class="headerlink" title="关键字可变长参数(字典)"></a>关键字可变长参数(字典)</h4><p>当我们有不定数目的或者额外的关键字参数时，我们需要将参数放入一个字典(字典的键为参数名，值对为相应的参数值)中。需要注意的是关键字可变长参数的位置在所有参数之后。</p>
<pre><code>def function_name(formal_args，*vargs_tuple， **vargs_dict):
    &apos;function_documentation_string&apos;
    function_body_suite

# eg
&gt;&gt;&gt; def dictVarArgs(arg1, arg2 = &apos;default&apos;, **theRest):
    &apos;display regular args and non_keyword variable args&apos;
    print &apos;formal arg 1:&apos;, arg1
    print &apos;formal arg 2:&apos;, arg2
    for eachXtrArg in theRest.keys():
        print &apos;Xtra arg %s: %s&apos; % (eachXtrArg, str(theRest[eachXtrArg]))


&gt;&gt;&gt; dictVarArgs(789,&apos;hi&apos;,language = &apos;Python&apos;)
formal arg 1: 789
formal arg 2: hi
Xtra arg language: Python
</code></pre><h2 id="u53D8_u91CF_u4F5C_u7528_u57DF"><a href="#u53D8_u91CF_u4F5C_u7528_u57DF" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量的作用域是定义为其声明在程序里的可应用范围。变量可以分为全局变量和局部变量。在Python中，一个模块中最高级别的变量具有全局作用域，也就是全局变量，它的一个特点是除非被删除，否则将存活于整个脚本之中。局部变量是指在函数体内创建的，一旦函数完成，变量就会被销毁。我们需要注意的是小心地使用和全局变量同名的局部变量。</p>
<p>如果在函数体内声明一个和全局变量同名的局部变量，全局变量的值在函数体内就会被覆盖，而该变量的全局特性和局部特性就不那么清晰。如果要在函数体内使用全局变量时，请在变量名前加上关键字<strong>global</strong>。</p>
<pre><code>&gt;&gt;&gt; name = &apos;Python&apos;
&gt;&gt;&gt; def func():
    global name
    print &apos;I like&apos;,name

&gt;&gt;&gt; func()
I like Python
</code></pre><h2 id="u5185_u5D4C_u51FD_u6570"><a href="#u5185_u5D4C_u51FD_u6570" class="headerlink" title="内嵌函数"></a>内嵌函数</h2><p>内嵌函数是指在函数体内创建另外一个函数。内嵌函数在外部函数的作用域内，如果没有对内嵌函数的外部引用，那么除了在外部函数体内，任何地方都无法访问内嵌函数。</p>
<pre><code>&gt;&gt;&gt; def foo():
        def bar():
            print &apos;bar() called.&apos;
        print &apos;foo() called.&apos;
        return bar

&gt;&gt;&gt; foo()
foo() called.
bar() called.
&gt;&gt;&gt; bar()

Traceback (most recent call last):
  File &quot;&lt;pyshell#88&gt;&quot;, line 1, in &lt;module&gt;
    bar()
NameError: name &apos;bar&apos; is not defined
</code></pre><p>内嵌函数更重要的是体现在’闭包’上面。</p>
<h3 id="u95ED_u5305_28closure_29"><a href="#u95ED_u5305_28closure_29" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h3><p>如果内嵌函数的定义中包含了在外部函数里定义的对象的引用，内部函数就会被称为<strong>闭包</strong></p>
<p>定义在外部函数内的但由内嵌函数引用或者使用的变量被称为<strong>自由变量</strong> </p>
<p>闭包的词法变量不属于全局名称空间域或者局部的，是属于其他的名称空间，带有流浪的作用域。</p>
<pre><code>&gt;&gt;&gt; def func(name):
        def inner_func(age):
            print &apos;name:&apos;, name, &apos;age:&apos;, age
        return inner_func

&gt;&gt;&gt; name = func(&apos;Python&apos;)
&gt;&gt;&gt; name(20)
name: Python age: 20
</code></pre><p>在这个例子中，当我们调用func时，就会产生一个闭包inner_func，并且该闭包持有自由变量name，当func的生命周期结束后，name这个变量依然存在，因为他被闭包引用了，暂时不会被回收。</p>
<p>在Python中，函数对象有一个<strong>closure</strong>属性，我们可以通过这个属性看看闭包的一些细节。</p>
<pre><code>&gt;&gt;&gt; print name.__closure__
(&lt;cell at 0x02B02FD0: str object at 0x026913E0&gt;,)
&gt;&gt;&gt; print type(name.__closure__[0])
&lt;type &apos;cell&apos;&gt;
&gt;&gt;&gt; print name.__closure__[0].cell_contents
Python
</code></pre><p>通过上面的理解，我们可以得出在Python中创建一个闭包可以归结为以下三点：</p>
<ul>
<li>闭包函数必须有内嵌函数</li>
<li>内嵌函数需要引用外部函数中的变量</li>
<li>闭包函数必须返回内嵌函数</li>
</ul>
<h2 id="u533F_u540D_u51FD_u6570"><a href="#u533F_u540D_u51FD_u6570" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>在Python中，可以使用关键字<strong>lambda</strong>来创建匿名函数。和标准函数几乎一样，只不过这个函数的定义和声明必须卸载同一行。匿名函数同样可以被调用或者引用。</p>
<p>标准函数：</p>
<pre><code>def add(x, y):
    return x + y
</code></pre><p>函数add()改写单行函数：</p>
<pre><code>def add(x, y): return x + y
</code></pre><p>函数add()改写匿名函数：</p>
<pre><code>lambda x, y: x + y
</code></pre><p>看上去匿名函数是一个函数的单行版本，匿名函数运行起来就像一个函数，当被调用时，就会创建一个框架对象。</p>
<h3 id="u5185_u5EFA_u51FD_u6570filter_28_29_u3001map_28_29_u3001reduce_28_29"><a href="#u5185_u5EFA_u51FD_u6570filter_28_29_u3001map_28_29_u3001reduce_28_29" class="headerlink" title="内建函数filter()、map()、reduce()"></a>内建函数filter()、map()、reduce()</h3><p>在列表的学习过程中，接触过这些函数式编程的内建函数，现在，使用lambda的形式来重新认识下。</p>
<h4 id="filter_28_29"><a href="#filter_28_29" class="headerlink" title="filter()"></a>filter()</h4><p>filter(function,sequence)方法是返回一个sequence(序列)，包括了给定序列中所有调用function(item)后返回值为true的元素。filter()函数可以看作一个过滤器来使用。</p>
<pre><code>&gt;&gt;&gt; def div_3_or_div_5(x):
    return x % 3 == 0 or x % 5 == 0
&gt;&gt;&gt; filter(div_3_or_div_5,range(0,21))
[0, 3, 5, 6, 9, 10, 12, 15, 18, 20]
</code></pre><p>改写后：</p>
<pre><code>&gt;&gt;&gt; filter(lambda x: x % 3 == 0 or x % 5 == 0, range(0,21))
[0, 3, 5, 6, 9, 10, 12, 15, 18, 20]
</code></pre><h4 id="map_28_29"><a href="#map_28_29" class="headerlink" title="map()"></a>map()</h4><p>map(function,sequence)方法是为每一个元素调用function(item)并将返回值组成一个新的列表返回。</p>
<pre><code>&gt;&gt;&gt; def cube(x):
    return x * x * x
&gt;&gt;&gt; map(cube,range(0,4))
[0, 1, 8, 27]
</code></pre><p>改写后：</p>
<pre><code>&gt;&gt;&gt; map(lambda x: x * x * x, range(0,4))
[0, 1, 8, 27]
</code></pre><h4 id="reduce_28_29"><a href="#reduce_28_29" class="headerlink" title="reduce()"></a>reduce()</h4><p>reduce(function,sequence)方法是返回一个单值，他的构造方法是：首先以序列的前两个元素调用函数function，再以返回值和第三个参数调用，依次下去。</p>
<pre><code>&gt;&gt;&gt; def sum(seq):
        def add(x, y):
            return x + y
        return reduce(add, seq, 0)
&gt;&gt;&gt; sum(range(1,101))
5050
</code></pre><p>改写后：</p>
<pre><code>&gt;&gt;&gt; reduce(lambda x, y: x + y,range(1,101))
5050
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>函数就是对程序逻辑进行结构化或过程化的一种编程方法。函数可以将我们编写的代码进行格式化，便于管理和理解，以及节约空间，减少代码的重复性。</p>
<h1 id="u51FD_u6570_u7684_u5B9A_u4E49"><a href="#u51FD_u6570_u76]]>
    </summary>
    
      <category term="函数" scheme="http://dsljlbaby.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="闭包" scheme="http://dsljlbaby.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之异常]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/03/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://dsljlbaby.github.io/2016/02/03/Python学习笔记之异常/</id>
    <published>2016-02-03T04:43:11.000Z</published>
    <updated>2016-02-03T07:32:28.332Z</updated>
    <content type="html"><![CDATA[<p>最初，学习Python编程语言时，我碰到好多不知所云的问题，有些比较容易解决，有些值得去揣摩。一旦出现错误，就会让我很苦恼。所以我觉得应该学习下什么是异常和错误，并且如何更好地处理这些异常。</p>
<h1 id="u9519_u8BEF"><a href="#u9519_u8BEF" class="headerlink" title="错误"></a>错误</h1><p>因为异常和错误几乎是相辅相成的，所以简单地了解下错误可以更好地帮助我们理解异常。编程语言中的错误是指语法上或者逻辑上的错误。</p>
<h2 id="u8BED_u6CD5_u9519_u8BEF"><a href="#u8BED_u6CD5_u9519_u8BEF" class="headerlink" title="语法错误"></a>语法错误</h2><p>语法错误是指软件的结构错误，导致不能够被解释器或者编译器无法编译。这类错误必须在程序执行前处理，否则，无法进行编译。通俗地理解，语法错误就是不符合一门语言的语法，在中文学习中就是病句，你写出来的句子，别人看不懂，无法理解你的想法，这样我们就无法交流。相同的，程序出现语法错误，编译器就不能理解你要它做的事，它就不会执行你的想法。</p>
<h2 id="u903B_u8F91_u9519_u8BEF"><a href="#u903B_u8F91_u9519_u8BEF" class="headerlink" title="逻辑错误"></a>逻辑错误</h2><p>逻辑错误是指逻辑无法生成，计算或者输出结果不满足期望。这类错误类似于中文语句的歧义，两个不同的人对一句话的理解有偏差。对于计算机来说，它可以执行你的指令，但不一定得出你想要的结果。</p>
<h1 id="u5F02_u5E38"><a href="#u5F02_u5E38" class="headerlink" title="异常"></a>异常</h1><p>异常是指程序出现了错误而在正常控制流以外采取的行为。这个行为又分为两个阶段：一是引起异常发生的错误，二是检测和采取可能的措施的阶段。</p>
<h2 id="u5F02_u5E38_u7684_u89E6_u53D1"><a href="#u5F02_u5E38_u7684_u89E6_u53D1" class="headerlink" title="异常的触发"></a>异常的触发</h2><p>这个阶段只要检测到错误并且意识到异常条件，解释器就会引发一个异常。解释器通过它通知当前控制流有错误发生，当前控制流就会被打断。</p>
<h2 id="u5F02_u5E38_u7684_u5904_u7406"><a href="#u5F02_u5E38_u7684_u5904_u7406" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>当程序的当前控制流被打断。引发异常后，就可以调用不同的操作来处理对应的异常，可以忽略错误，或者减轻错误的成度，这个处理的过程关键在于编程者在错误发生时如何指示程序执行。</p>
<p>我们在这个过程中，不仅需要有检测错误的能力，还需要有相应的补救措施。</p>
<h1 id="Python_u4E2D_u7684_u5F02_u5E38"><a href="#Python_u4E2D_u7684_u5F02_u5E38" class="headerlink" title="Python中的异常"></a>Python中的异常</h1><p>在学习Python语言过程中，碰到了不少的错误，起初是无法理解的，慢慢地，经过整理发现，我们会经常碰见以下几类错误。</p>
<ul>
<li>NameError:未声明/未初始化对象</li>
<li>SyntaxError:Python解释器语法错误</li>
<li>ZeroDivisionError:除零错误</li>
<li>AttributeError:对象没有这个属性</li>
<li>IOError:输入输出操作失败</li>
<li>IndexError:序列中无此索引</li>
<li>TypeError:对类型无效的操作</li>
<li>ValueError:传入无效的参数</li>
<li>KeyError:访问一个不存在的字典关键字</li>
</ul>
<h2 id="Python_u5F02_u5E38_u5904_u7406_u7684_u65B9_u6CD5"><a href="#Python_u5F02_u5E38_u5904_u7406_u7684_u65B9_u6CD5" class="headerlink" title="Python异常处理的方法"></a>Python异常处理的方法</h2><p>在Python中，异常可以通过try语句进行检测。try语句主要有两种主要形式：try-except和try-finally。这两种语句的功能时相反的，try-except语句用作检测和处理异常。try-finally只能检测异常并做一些清楚工作。</p>
<h3 id="try-except_u8BED_u53E5"><a href="#try-except_u8BED_u53E5" class="headerlink" title="try-except语句"></a>try-except语句</h3><p>try-except语句用作检测和处理异常。</p>
<pre><code>try:
    try_suite # 检测异常的发生
except Exception[,reason]:
    except_suite # 异常的处理
</code></pre><p>在程序运行时，解释器尝试执行try语句块里里面的代码，如果代码检测完成后没有异常发生，执行流就会忽略except语句，执行下一语句，如果检测过程中发现异常，就会跳到对应的except处理器中，进行异常的处理。</p>
<pre><code>&gt;&gt;&gt; def safe_float(obj):
    try:
        retval = float(obj)
    except ValueError:
        retval = &apos;could not convert no-number to float.&apos;
    return retval

&gt;&gt;&gt; safe_float(&apos;12&apos;)
12.0
&gt;&gt;&gt; safe_float(&apos;Python&apos;)
&apos;could not convert no-number to float.&apos;
</code></pre><h4 id="u5E26_u6709_u591A_u4E2Aexcept_u7684try_u8BED_u53E5"><a href="#u5E26_u6709_u591A_u4E2Aexcept_u7684try_u8BED_u53E5" class="headerlink" title="带有多个except的try语句"></a>带有多个except的try语句</h4><pre><code>try:
    try_suite # 检测异常的发生
except Exception1[,reason1]:
    except_suite1 # 异常的处理1
except Exception2[,reason2]:
    except_suite2 # 异常的处理2
       .
       .
       .
# eg
&gt;&gt;&gt; def safe_float(obj):
    try:
        retval = float(obj)
    except ValueError:
        retval = &apos;could not convert no-number to float.&apos;
    except TypeError:
        retval = &apos;object type could not be converted to float.&apos;
    return retval

&gt;&gt;&gt; safe_float(&apos;Python&apos;)
&apos;could not convert no-number to float.&apos;
&gt;&gt;&gt; safe_float([&apos;Python&apos;])
&apos;object type could not be converted to float.&apos;
</code></pre><h4 id="u5904_u7406_u591A_u4E2A_u5F02_u5E38_u7684expect_u8BED_u53E5"><a href="#u5904_u7406_u591A_u4E2A_u5F02_u5E38_u7684expect_u8BED_u53E5" class="headerlink" title="处理多个异常的expect语句"></a>处理多个异常的expect语句</h4><pre><code>try:
    try_suite # 检测异常的发生
except （Exception1，Exception2...)[,reason]: # 多个异常放在一个元组中
    except_suite # 异常的处理

# eg
&gt;&gt;&gt; def safe_float(obj):
    try:
        retval = float(obj)
    except (ValueError,TypeError):
        retval = &apos;argument must be a number or numberic string.&apos;
    return retval

&gt;&gt;&gt; safe_float(&apos;Python&apos;)
&apos;argument must be a number or numberic string.&apos;
&gt;&gt;&gt; safe_float([&apos;Python&apos;])
&apos;argument must be a number or numberic string.&apos;
</code></pre><h4 id="u5E26_u6709else_u7684try_u8BED_u53E5"><a href="#u5E26_u6709else_u7684try_u8BED_u53E5" class="headerlink" title="带有else的try语句"></a>带有else的try语句</h4><p>else语句可以用于条件和循环语句中，同样地，也可以和try-except搭配使用。在else范围中的任何代码执行前，try范围中的所有代码必须无异常。</p>
<pre><code>try:
    try_suite # 检测异常的发生
except Exception[,reason]:
    except_suite # 异常的处理
else:
    else_suite # else语句的执行
</code></pre><h4 id="u6355_u83B7_u6240_u6709_u7684_u5F02_u5E38"><a href="#u6355_u83B7_u6240_u6709_u7684_u5F02_u5E38" class="headerlink" title="捕获所有的异常"></a>捕获所有的异常</h4><pre><code>try:
   :
except Exception, e:
   # error occurred, log &apos;e&apos;. &apos;etc&apos;
</code></pre><p>捕获所有异常，有些异常并不是由于错误引起的，它们是SystemExit(由于当前的Python程序需要退出)和KeyboardInterupt(用户按下CTRL-C，想要关闭Python)。</p>
<p>异常的一部分内容在py2.5以后有相应的改变，启用了一个新的“所有异常之母”的类，这个类叫做BaseException。KeyboardInterrupt和SystemExit和Exception平级，都是继承于BaseException。</p>
<pre><code>&gt;&gt;&gt; def safe_float(obj):
    try:
        retval = float(obj)
    except Exception,e:
        retval = e
    return retval

&gt;&gt;&gt; safe_float(&apos;Python&apos;)
ValueError(&apos;could not convert string to float: Python&apos;,)
&gt;&gt;&gt; safe_float([&apos;Python&apos;])
TypeError(&apos;float() argument must be a string or a number&apos;,)
</code></pre><h3 id="try-finally_u8BED_u53E5"><a href="#try-finally_u8BED_u53E5" class="headerlink" title="try-finally语句"></a>try-finally语句</h3><p>finally范围的语句是无论异常是否发生和是否捕获，都会执行的一段代码。可以和try单独使用，也可以和try-except联合使用。</p>
<pre><code>try:
    try_suite 
finally:
    finally_suite # 无论如何都会执行
</code></pre><p>当在try范围内产生一个异常时，控制流就会跳转到finally语句段，当finally中的所有代码执行完，会继续向上层引发异常。</p>
<pre><code># 语句1
try:
    try:
        A
    except MyException:
        B
finally:
    C
#语句2
try:
    try:
        A
    finally:
        C
except MyException:
    B
</code></pre><p>上面这两种代码实的本质是一样的，区别在于处理异常的代码块的位置。语句2可以同时处理原始try范围和finally范围内的异常，但是，当finally范围内的确发生异常或者存在return、break、continue语句时，就可能会丢失原来异常的上下文信息且无法重新触发。语句1可以避免掉语句2的问题，但是当finally语句中出现异常时，就无法处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最初，学习Python编程语言时，我碰到好多不知所云的问题，有些比较容易解决，有些值得去揣摩。一旦出现错误，就会让我很苦恼。所以我觉得应该学习下什么是异常和错误，并且如何更好地处理这些异常。</p>
<h1 id="u9519_u8BEF"><a href="#u9519_]]>
    </summary>
    
      <category term="异常" scheme="http://dsljlbaby.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="错误" scheme="http://dsljlbaby.github.io/tags/%E9%94%99%E8%AF%AF/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之集合]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>http://dsljlbaby.github.io/2016/02/02/Python学习笔记之集合/</id>
    <published>2016-02-02T07:06:54.000Z</published>
    <updated>2016-02-13T07:40:13.282Z</updated>
    <content type="html"><![CDATA[<p>在数学上，我们把由不同的元素组成的容器叫做集合。Python引入了这一概念，集合对象是一组无序排列的可哈希的值。在Python中，集合有两种不同的类型：可变集合(set)和不可变集合(frozenset)。</p>
<h1 id="u96C6_u5408_28set_29"><a href="#u96C6_u5408_28set_29" class="headerlink" title="集合(set)"></a>集合(set)</h1><p>在数学上，我们把由不同的元素组成的容器叫做集合。Python引入了这一概念，集合对象是一组无序排列的可哈希的值。在Python中，集合有两种不同的类型：可变集合(set)和不可变集合(frozenset)。对于可变集合来说，像列表一样可以删除和添加元素，对于不可变集合来说，则不允许这样做。</p>
<h2 id="u96C6_u5408_u7684_u521B_u5EFA"><a href="#u96C6_u5408_u7684_u521B_u5EFA" class="headerlink" title="集合的创建"></a>集合的创建</h2><p>集合可以通过set()方法和frozenset()方法来创建。</p>
<pre><code>&gt;&gt;&gt; set(&apos;language&apos;)
set([&apos;a&apos;, &apos;e&apos;, &apos;g&apos;, &apos;l&apos;, &apos;n&apos;, &apos;u&apos;])
&gt;&gt;&gt; frozenset(&apos;Chinese&apos;)
frozenset([&apos;C&apos;, &apos;e&apos;, &apos;i&apos;, &apos;h&apos;, &apos;n&apos;, &apos;s&apos;])
</code></pre><h2 id="u96C6_u5408_u7684_u8BBF_u95EE"><a href="#u96C6_u5408_u7684_u8BBF_u95EE" class="headerlink" title="集合的访问"></a>集合的访问</h2><p>可以通过遍历的方法来访问。无法像序列或者字典那样单一地访问某一元素。</p>
<pre><code>&gt;&gt;&gt; for i in set(&apos;language&apos;):
    print i,


a e g l n u
</code></pre><h2 id="u96C6_u5408_u7684_u66F4_u65B0"><a href="#u96C6_u5408_u7684_u66F4_u65B0" class="headerlink" title="集合的更新"></a>集合的更新</h2><p>只有可变集合才可以添加或删除集合的成员，不可变集合无法执行。</p>
<pre><code>&gt;&gt;&gt; set1 = set(&apos;language&apos;)
&gt;&gt;&gt; set1.add(&apos;d&apos;)
&gt;&gt;&gt; set1
set([&apos;a&apos;, &apos;e&apos;, &apos;d&apos;, &apos;g&apos;, &apos;l&apos;, &apos;n&apos;, &apos;u&apos;])
&gt;&gt;&gt; set1.remove(&apos;d&apos;)
&gt;&gt;&gt; set1
set([&apos;a&apos;, &apos;e&apos;, &apos;g&apos;, &apos;l&apos;, &apos;n&apos;, &apos;u&apos;])
&gt;&gt;&gt; set1.update(&apos;hello&apos;)
&gt;&gt;&gt; set1
set([&apos;a&apos;, &apos;e&apos;, &apos;g&apos;, &apos;h&apos;, &apos;l&apos;, &apos;o&apos;, &apos;n&apos;, &apos;u&apos;])
</code></pre><h2 id="u96C6_u5408_u7C7B_u578B_u64CD_u4F5C_u7B26"><a href="#u96C6_u5408_u7C7B_u578B_u64CD_u4F5C_u7B26" class="headerlink" title="集合类型操作符"></a>集合类型操作符</h2><p>类似in/not in 、&gt;、&lt;等操作符同样地适合集合。</p>
<h3 id="u8054_u5408_28_7C_29"><a href="#u8054_u5408_28_7C_29" class="headerlink" title="联合(|)"></a>联合(|)</h3><p>联合操作等价于集合的or。两个集合的联合是一个新集合，该集合中的每个元素至少是其中一个集合的成员。</p>
<pre><code>&gt;&gt;&gt; set1 = set(&apos;language&apos;)
&gt;&gt;&gt; set2 = set(&apos;Chinese&apos;)
&gt;&gt;&gt; set3 = set1 | set2
&gt;&gt;&gt; set3
set([&apos;a&apos;, &apos;C&apos;, &apos;e&apos;, &apos;g&apos;, &apos;i&apos;, &apos;h&apos;, &apos;l&apos;, &apos;n&apos;, &apos;s&apos;, &apos;u&apos;])
</code></pre><h3 id="u4EA4_u96C6_28_26amp_3B_29"><a href="#u4EA4_u96C6_28_26amp_3B_29" class="headerlink" title="交集(&amp;)"></a>交集(&amp;)</h3><p>交集操作等价于集合的and。两个集合的交集是一个新集合，该集合中的每一个元素同时是两个集合的成员。</p>
<pre><code>&gt;&gt;&gt; set4 = set1 &amp; set2
&gt;&gt;&gt; set4
set([&apos;e&apos;, &apos;n&apos;])
</code></pre><h3 id="u5DEE_u8865_28-_29"><a href="#u5DEE_u8865_28-_29" class="headerlink" title="差补(-)"></a>差补(-)</h3><p>两个集合的差补是指一个集合Ｃ，只属于集合Ｓ，而不属于集合Ｔ。</p>
<pre><code>&gt;&gt;&gt; set5 = set1 - set2
&gt;&gt;&gt; set5
set([&apos;a&apos;, &apos;u&apos;, &apos;l&apos;, &apos;g&apos;])
</code></pre><h3 id="u5BF9_u79F0_u5DEE_u5206_28_5E_29"><a href="#u5BF9_u79F0_u5DEE_u5206_28_5E_29" class="headerlink" title="对称差分(^)"></a>对称差分(^)</h3><p>对称差分等价于集合的XOR（异或），两个集合的对称差分是一个新集合，该集合中的成员只能属于集合S或者集合T，不能同时属于两个集合。</p>
<pre><code>&gt;&gt;&gt; set6 = set1 ^ set2
&gt;&gt;&gt; set6
set([&apos;a&apos;, &apos;C&apos;, &apos;l&apos;, &apos;u&apos;, &apos;g&apos;, &apos;i&apos;, &apos;h&apos;, &apos;s&apos;])
</code></pre><h3 id="u6DF7_u5408_u96C6_u5408"><a href="#u6DF7_u5408_u96C6_u5408" class="headerlink" title="混合集合"></a>混合集合</h3><p>如果操作符左边的集合属于可变集合，操作符右边的集合属于不可变集合，经过任意操作符运算后，得到的新集合类型和左边的集合类型保持一致。</p>
<pre><code>&gt;&gt;&gt; set1 = set(&apos;language&apos;)
&gt;&gt;&gt; set2 = frozenset(&apos;Chinese&apos;)
&gt;&gt;&gt; set3 = set1 ^ set2
&gt;&gt;&gt; type(set3)
&lt;type &apos;set&apos;&gt;
&gt;&gt;&gt; set4 = set2 - set1
&gt;&gt;&gt; type(set4)
&lt;type &apos;frozenset&apos;&gt;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>在数学上，我们把由不同的元素组成的容器叫做集合。Python引入了这一概念，集合对象是一组无序排列的可哈希的值。在Python中，集合有两种不同的类型：可变集合(set)和不可变集合(frozenset)。</p>
<h1 id="u96C6_u5408_28set_29"]]>
    </summary>
    
      <category term="集合" scheme="http://dsljlbaby.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之字典]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E5%85%B8/"/>
    <id>http://dsljlbaby.github.io/2016/02/02/Python学习笔记之字典/</id>
    <published>2016-02-02T03:11:26.000Z</published>
    <updated>2016-02-13T07:41:28.530Z</updated>
    <content type="html"><![CDATA[<p>字典是Python语言中唯一的映射类型。字典在某些语言中被称为联合内存或者联合数组。序列是以连续的整数为索引，而字典是以关键字为索引的，关键字可以是任何不可变类型的。</p>
<h1 id="u5B57_u5178_28dict_29"><a href="#u5B57_u5178_28dict_29" class="headerlink" title="字典(dict)"></a>字典(dict)</h1><p>字典是Python语言中唯一的映射类型。字典在某些语言中被称为联合内存或者联合数组。序列是以连续的整数为索引，而字典是以关键字为索引的，关键字可以是任何不可变类型的。字典类型和序列类型容器类(列表、元组)的区别在于两者的存储和访问数据的方式不同。序列类型只能用数字类型的键，映射类型可以用任何不可变类型的对象，一般情况下是用字符串做键。映射类型中的数据是无序排列的。序列类型用有序的数字键做索引将数据以数组的形式存储。</p>
<p>映射类型通常被称为哈希表是因为字典对象就是哈希类型的。</p>
<p><em>哈希表中储存的每一条数据叫做一个值(value),是根据与它相关的一个被称为键(key)的数据项进行储存的。哈希表的算法是获取键，对键执行一个叫做哈希函数的操作，并根据计算的结果，选择在数据结构的某个地址中来储存值。任何一个值存储的地址皆取决于它的键。我们可以用items()方法得到包含键、值对的元组的列表来排序。</em></p>
<h2 id="u5B57_u5178_u7684_u521B_u5EFA"><a href="#u5B57_u5178_u7684_u521B_u5EFA" class="headerlink" title="字典的创建"></a>字典的创建</h2><p>我们可以把字典看作无序的<strong>键:值对</strong>集合，键必须互不相同，一对大括号{}创建一个空字典。初始化字典时，在大括号内放置一组逗号分隔的键:值对。</p>
<pre><code>&gt;&gt;&gt; dict1 = {}
&gt;&gt;&gt; dict2 = {&apos;name&apos;:&apos;Joe&apos;,&apos;age&apos;:20}
&gt;&gt;&gt; dict1,dict2
({}, {&apos;age&apos;: 20, &apos;name&apos;: &apos;Joe&apos;})
</code></pre><h2 id="u5B57_u5178_u7684_u8BBF_u95EE"><a href="#u5B57_u5178_u7684_u8BBF_u95EE" class="headerlink" title="字典的访问"></a>字典的访问</h2><p>我们一般可以通过dictname[key]来访问字典的值对或者通过迭代器来访问。</p>
<pre><code>&gt;&gt;&gt; dict2[&apos;age&apos;]
20
&gt;&gt;&gt; for key in dict2:
    print &apos;key = %s, value = %s&apos; % (key,dict2[key])


key = age, value = 20
key = name, value = Joe
</code></pre><h2 id="u5B57_u5178_u7684_u66F4_u65B0"><a href="#u5B57_u5178_u7684_u66F4_u65B0" class="headerlink" title="字典的更新"></a>字典的更新</h2><p>我们可以通过dictname[key]来更新字典的值对，通过del语句删除某一个键：值对。</p>
<pre><code>&gt;&gt;&gt; dict2[&apos;name&apos;] = &apos;Bob&apos; # 替换条目
&gt;&gt;&gt; dict2
{&apos;age&apos;: 20, &apos;name&apos;: &apos;Bob&apos;}
&gt;&gt;&gt; dict2[&apos;sex&apos;] = &apos;male&apos; # 添加条目
&gt;&gt;&gt; dict2
{&apos;age&apos;: 20, &apos;name&apos;: &apos;Bob&apos;, &apos;sex&apos;: &apos;male&apos;}
&gt;&gt;&gt; del dict2[&apos;sex&apos;]  # 删除条目
&gt;&gt;&gt; dict2
{&apos;age&apos;: 20, &apos;name&apos;: &apos;Bob&apos;}
</code></pre><h2 id="u5B57_u5178_u64CD_u4F5C_u7B26"><a href="#u5B57_u5178_u64CD_u4F5C_u7B26" class="headerlink" title="字典操作符"></a>字典操作符</h2><p>字典类型操作符除了不支持拼接(+)和重复(*)这样的操作，其他操作和序列操作几乎一样。</p>
<h3 id="u57FA_u672C_u64CD_u4F5C_u7B26"><a href="#u57FA_u672C_u64CD_u4F5C_u7B26" class="headerlink" title="基本操作符"></a>基本操作符</h3><p>由于字典类型操作符和序列操作符几乎一样，这里不做说明。</p>
<pre><code>&gt;&gt;&gt; dict3 = {&apos;abc&apos;:123}
&gt;&gt;&gt; dict4 = {&apos;abc&apos;:456}
&gt;&gt;&gt; dict5 = {&apos;abc&apos;:123,456:789}
&gt;&gt;&gt; dict6 = {&apos;xyz&apos;:123}
&gt;&gt;&gt; dict3 &gt; dict4
False
&gt;&gt;&gt; (dict4 &lt; dict5) and (dict4 &lt; dict6)
True
&gt;&gt;&gt; &apos;abc&apos; in dict3
True
&gt;&gt;&gt; &apos;abc&apos; in dict6
False
</code></pre><h3 id="u5B57_u5178_u7684_u6BD4_u8F83"><a href="#u5B57_u5178_u7684_u6BD4_u8F83" class="headerlink" title="字典的比较"></a>字典的比较</h3><p>由于字典的比较比较复杂，所以这里单独说明。对于字典来说，cmp()方法比较的算法是按照先比较字典的长度，再比较字典的键，最后比较字典的值对。</p>
<h4 id="u6BD4_u8F83_u5B57_u5178_u7684_u957F_u5EA6"><a href="#u6BD4_u8F83_u5B57_u5178_u7684_u957F_u5EA6" class="headerlink" title="比较字典的长度"></a>比较字典的长度</h4><p>如果字典的长度不同，那么用cmp(dict1,dict2)比较大小时，如果字典dict1比dict2长，cmp()返回正值，反之负值。</p>
<pre><code>&gt;&gt;&gt; cmp(dict3,dict5)
-1
&gt;&gt;&gt; cmp(dict5,dict4)
1
</code></pre><h4 id="u6BD4_u8F83_u5B57_u5178_u7684_u952E"><a href="#u6BD4_u8F83_u5B57_u5178_u7684_u952E" class="headerlink" title="比较字典的键"></a>比较字典的键</h4><p>如果字典的长度相同，那么就会按照字典的键比较。</p>
<pre><code>&gt;&gt;&gt; cmp(dict3,dict6)
-1
</code></pre><h4 id="u6BD4_u8F83_u5B57_u5178_u7684_u503C_u5BF9"><a href="#u6BD4_u8F83_u5B57_u5178_u7684_u503C_u5BF9" class="headerlink" title="比较字典的值对"></a>比较字典的值对</h4><p>如果字典的长度和键都相同的情况下，就会按照字典的值对进行比较。</p>
<pre><code>&gt;&gt;&gt; cmp(dict3,dict4)
-1
</code></pre><h3 id="hash_28_29_u51FD_u6570"><a href="#hash_28_29_u51FD_u6570" class="headerlink" title="hash()函数"></a>hash()函数</h3><p>hash()函数本身并不是为字典设计的方法，但它可以判断某个队形是否可以做一个字典的键，将一个 对象作为参数传递给hash()，会返回这个队形的哈希值。只有这个对象是可哈希的，才可以作为字典的键。非可哈希类型传递给hash()方法，会产生TypeError错误。</p>
<pre><code>&gt;&gt;&gt; hash([&apos;abc&apos;])

Traceback (most recent call last):
    File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;
    hash([&apos;abc&apos;])
TypeError: unhashable type: &apos;list&apos;
&gt;&gt;&gt; hash((&apos;abc&apos;,))
594755148
</code></pre><h3 id="u5B57_u5178_u7684_u5185_u5EFA_u65B9_u6CD5"><a href="#u5B57_u5178_u7684_u5185_u5EFA_u65B9_u6CD5" class="headerlink" title="字典的内建方法"></a>字典的内建方法</h3><ul>
<li>dict.keys() 返回一个包含字典中键的列表</li>
<li>dict.values() 返回一个包含字典中所有值得列表</li>
<li>dict.items() 返回一个包含字典中键、值对元组的列表</li>
<li>dict.update(dict1) 将字典dict1的键-值对更新到字典dict中，字典中原有的键如果和新添加的键重复，那么重复键所对应的值对将会覆盖原来的值对，原来不存在的条目将会添加到字典中</li>
<li>dict.iter*() iteritems()、iterkeys()、itervalues()返回的是一个迭代子，而不是一个列表。</li>
</ul>
<p>代码：</p>
<pre><code>&gt;&gt;&gt; dict1 = {&apos;age&apos;: 20, &apos;name&apos;: &apos;Bob&apos;, &apos;sex&apos;: &apos;male&apos;}
dict2 = {&apos;name&apos;: &apos;Steven&apos;,&apos;city&apos;:&apos;New York&apos;,&apos;age&apos;:24}
&gt;&gt;&gt; dict1.values()
[20, &apos;Bob&apos;, &apos;male&apos;]
&gt;&gt;&gt; dict1.keys()
[&apos;age&apos;, &apos;name&apos;, &apos;sex&apos;]
&gt;&gt;&gt; dict1.update(dict2)
&gt;&gt;&gt; dict1
{&apos;city&apos;: &apos;New York&apos;, &apos;name&apos;: &apos;Steven&apos;, &apos;age&apos;: 24, &apos;sex&apos;: &apos;male&apos;}
&gt;&gt;&gt; for value in dict1.itervalues():
    print value


Steven
19
female
&gt;&gt;&gt; for key in dict1.iterkeys():
    print key


name
age
sex
&gt;&gt;&gt; for item in dict1.iteritems():
    print item


(&apos;name&apos;, &apos;Steven&apos;)
(&apos;age&apos;, 19)
(&apos;sex&apos;, &apos;female&apos;)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>字典是Python语言中唯一的映射类型。字典在某些语言中被称为联合内存或者联合数组。序列是以连续的整数为索引，而字典是以关键字为索引的，关键字可以是任何不可变类型的。</p>
<h1 id="u5B57_u5178_28dict_29"><a href="#u5B57_u5]]>
    </summary>
    
      <category term="字典" scheme="http://dsljlbaby.github.io/tags/%E5%AD%97%E5%85%B8/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之元组]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/01/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%83%E7%BB%84/"/>
    <id>http://dsljlbaby.github.io/2016/02/01/Python学习笔记之元组/</id>
    <published>2016-02-01T08:51:13.000Z</published>
    <updated>2016-02-13T07:41:28.529Z</updated>
    <content type="html"><![CDATA[<p>元组是一种和列表非常相近的序列类型，两者的不同之处在于元组是一种不可变类型，而列表是一种可变类型，再者，就是元组的表示使用圆括弧()，列表的表示使用方括号[]。两者都可以接受任意类型作为元素。</p>
<h1 id="u5143_u7EC4_28tuple_29"><a href="#u5143_u7EC4_28tuple_29" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h1><p>元组是一种和列表非常相近的序列类型，两者的不同之处在于元组是一种不可变类型，而列表是一种可变类型，再者，就是元组的表示使用圆括弧()，列表的表示使用方括号[]。两者都可以接受任意类型作为元素。也正因为元组是一种不可变类型容器，元组可以用作字典的key，这是列表不能做的事。</p>
<h2 id="u5143_u7EC4_u7684_u521B_u5EFA"><a href="#u5143_u7EC4_u7684_u521B_u5EFA" class="headerlink" title="元组的创建"></a>元组的创建</h2><p>创建一个元组的方法和创建一个列表的方法类似，唯一不同的在于，元组只有一个元素时，需要在元组分隔符里面加一个逗号(,)，防止和普通的分组操作符相混淆。</p>
<pre><code>&gt;&gt;&gt; aTuple = (123,&apos;abc&apos;,4.56,(&apos;xyz&apos;,-789))
&gt;&gt;&gt; aTuple
(123, &apos;abc&apos;, 4.56, (&apos;xyz&apos;, -789))
&gt;&gt;&gt; aTuple1 = (&apos;abc&apos;)
&gt;&gt;&gt; aTuple1
&apos;abc&apos;
&gt;&gt;&gt; type(aTuple1)
&lt;type &apos;str&apos;&gt;
&gt;&gt;&gt; aTuple2 = (&apos;abc&apos;,)
&gt;&gt;&gt; aTuple2
(&apos;abc&apos;,)
&gt;&gt;&gt; type(aTuple2)
&lt;type &apos;tuple&apos;&gt;
</code></pre><h2 id="u5143_u7EC4_u7684_u8BBF_u95EE"><a href="#u5143_u7EC4_u7684_u8BBF_u95EE" class="headerlink" title="元组的访问"></a>元组的访问</h2><p>元组的访问和序列的访问方法是一样的，都可以通过下标或者切片操作来访问一个或者一段连续的数据元素。</p>
<pre><code>&gt;&gt;&gt; aTuple = (123,&apos;abc&apos;,4.56,(&apos;xyz&apos;,-789))
&gt;&gt;&gt; aTuple[1]
&apos;abc&apos;
&gt;&gt;&gt; aTuple[:4]
(123, &apos;abc&apos;, 4.56, (&apos;xyz&apos;, -789))
&gt;&gt;&gt; aTuple[3][0]
&apos;xyz&apos;
</code></pre><h2 id="u5143_u7EC4_u7684_u4FEE_u6539"><a href="#u5143_u7EC4_u7684_u4FEE_u6539" class="headerlink" title="元组的修改"></a>元组的修改</h2><p>由于元组是一种不可变类型容器，所以它和字符串一样，无法对元组的某个元素值进行操作，只能通过构建新的元组。我们可以使用del语句进行删除一个元组。</p>
<pre><code>del aTuple
</code></pre><h2 id="u5143_u7EC4_u64CD_u4F5C_u7B26"><a href="#u5143_u7EC4_u64CD_u4F5C_u7B26" class="headerlink" title="元组操作符"></a>元组操作符</h2><p>元组的对象和序列类型操作符和内建函数跟列表的完全一样，我们仍然可以对元组进行切片操作、合并操作、多次拷贝、测试一个对象是否属于一个元组以及元组之间的比较。</p>
<p>由于元组是不可变的，所以列表的方法(排序、替换、添加等)对元组就无法使用。</p>
<h2 id="u5143_u7EC4_u7684_u7279_u6B8A_u6027"><a href="#u5143_u7EC4_u7684_u7279_u6B8A_u6027" class="headerlink" title="元组的特殊性"></a>元组的特殊性</h2><p>不可变对象的值不可改变的，这意味着他们可以通过hash算法得到的值总是一个值，这就可以作为字典键值的一个必备条件。由于元组在一定程度上，并不是完全不可变的，所以用元组做有效的键值时，必须有所限制：元组中只包括像数字和字符串这样不可变参数，才可以做字典中有效的键值。</p>
<h2 id="u5217_u8868_VS__u5143_u7EC4"><a href="#u5217_u8868_VS__u5143_u7EC4" class="headerlink" title="列表 VS 元组"></a>列表 VS 元组</h2><p>既然列表和元组是两个相似的序列类型，那么我们为什么又要区分它们呢？</p>
<p>原因在于，有时候我们维护一些敏感的数据，并且需要把它传给一个不了解的函数或者API时，这时候使用元组就比较安全，至少这些被调用的函数不会那么轻易地更改我们的数据；相反，我们有时候在管理动态数据集合时，我们需要不时地更新数据，使用列表就比较方便。</p>
<p>我们可以使用list()方法将一个元组作为参数转化成列表类型，相反，我们使用tuple()方法将一个列表作为参数也可以转化成元组类型，供我们使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>元组是一种和列表非常相近的序列类型，两者的不同之处在于元组是一种不可变类型，而列表是一种可变类型，再者，就是元组的表示使用圆括弧()，列表的表示使用方括号[]。两者都可以接受任意类型作为元素。</p>
<h1 id="u5143_u7EC4_28tuple_29"><a h]]>
    </summary>
    
      <category term="元组" scheme="http://dsljlbaby.github.io/tags/%E5%85%83%E7%BB%84/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之列表]]></title>
    <link href="http://dsljlbaby.github.io/2016/02/01/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%97%E8%A1%A8/"/>
    <id>http://dsljlbaby.github.io/2016/02/01/Python学习笔记之列表/</id>
    <published>2016-02-01T02:57:10.000Z</published>
    <updated>2016-02-13T07:40:36.849Z</updated>
    <content type="html"><![CDATA[<p>列表类型也是序列式的数据类型。和字符串类型一样，可以通过下标或者切片操作来访问一个或者一段连续的元素。不同的是，字符串是不可变的，而列表具有可变容器的特性，使用起来比较灵活，列表容器的元素的数据类型可以是任意类型。</p>
<h1 id="u5217_u8868_28list_29"><a href="#u5217_u8868_28list_29" class="headerlink" title="列表(list)"></a>列表(list)</h1><p>列表类型也是序列式的数据类型。和字符串类型一样，可以通过下标或者切片操作来访问一个或者一段连续的元素。不同的是，字符串是不可变的，而列表具有可变容器的特性，列表可以添加或者删除元素，此外列表类型的元素还可以是任意类型组合的。</p>
<h2 id="u5217_u8868_u7684_u521B_u5EFA"><a href="#u5217_u8868_u7684_u521B_u5EFA" class="headerlink" title="列表的创建"></a>列表的创建</h2><p>创建一个列表比较简单，和创建一个字符串是类似的，只不过列表是由([])来定义的，元素类型可以是整形，浮点型，字符串，甚至还可以是列表。</p>
<pre><code>&gt;&gt;&gt; aList = [&apos;abc&apos;,123,4.56,[&apos;xyz&apos;,789,-28]]
&gt;&gt;&gt; aList
[&apos;abc&apos;, 123, 4.56, [&apos;xyz&apos;, 789, -28]]
</code></pre><h2 id="u5217_u8868_u7684_u8BBF_u95EE"><a href="#u5217_u8868_u7684_u8BBF_u95EE" class="headerlink" title="列表的访问"></a>列表的访问</h2><p>列表的访问和字符串的访问方法是一样的，都可以通过下标或者切片操作来访问一个或者一段连续的数据元素。</p>
<pre><code>&gt;&gt;&gt; aList = [&apos;abc&apos;,123,4.56,[&apos;xyz&apos;,789,-28]]
&gt;&gt;&gt; aList[3]
[&apos;xyz&apos;, 789, -28]
&gt;&gt;&gt; aList[0:3]
[&apos;abc&apos;, 123, 4.56]
&gt;&gt;&gt; aList[3][2]
-28
</code></pre><h2 id="u5217_u8868_u7684_u66F4_u65B0"><a href="#u5217_u8868_u7684_u66F4_u65B0" class="headerlink" title="列表的更新"></a>列表的更新</h2><p>与字符串不同的是，列表具有可变性，所以，列表可以更新某一元素的值，还可以通过append()或者insert()方法来添加新的元素到列表中，同样地，可以通过pop()或remove()方法删除某一元素。</p>
<ul>
<li>list.append(x)方法是把一个元素添加到链表的结尾</li>
<li>list.insert(index,x)方法是在指定位置插入一个元素</li>
<li>list.remove(x)方法是删除列表中值为x的元素</li>
<li>list.pop([index])方法是删除列表中索引为index的元素</li>
</ul>
<p>代码：</p>
<pre><code>&gt;&gt;&gt; aList = [&apos;abc&apos;,123,4.56,[&apos;xyz&apos;,789,-28]]
&gt;&gt;&gt; aList[0] = &apos;lmn&apos;
&gt;&gt;&gt; aList
[&apos;lmn&apos;, 123, 4.56, [&apos;xyz&apos;, 789, -28]]
&gt;&gt;&gt; aList.append(&apos;abc&apos;)
&gt;&gt;&gt; aList
[&apos;lmn&apos;, 123, 4.56, [&apos;xyz&apos;, 789, -28], &apos;abc&apos;]
&gt;&gt;&gt; aList.remove(&apos;lmn&apos;)
&gt;&gt;&gt; aList
[123, 4.56, [&apos;xyz&apos;, 789, -28], &apos;abc&apos;]
&gt;&gt;&gt; aList.pop(0)
123
&gt;&gt;&gt; aList
[4.56, [&apos;xyz&apos;, 789, -28], &apos;abc&apos;]
</code></pre><p>注意：pop()方法和remove()方法不同之处在于pop()方法是通过列表的索引进行删除元素并且返回删除的元素值，而remove()是直接删除一个元素值得。</p>
<h2 id="u5217_u8868_u7C7B_u578B_u64CD_u4F5C_u7B26"><a href="#u5217_u8868_u7C7B_u578B_u64CD_u4F5C_u7B26" class="headerlink" title="列表类型操作符"></a>列表类型操作符</h2><p>因为列表是属于序列的一类，所以序列中常见的操作符（成员关系操作符（in 、not in）、连接操作符（+）、重复操作符（*）、切片操作符（[]、[:]、[::]））都适用于字符串。</p>
<h3 id="u5217_u8868_u89E3_u6790"><a href="#u5217_u8868_u89E3_u6790" class="headerlink" title="列表解析"></a>列表解析</h3><p>列表除了常见的序列类型的操作符之外，列表拥有只属于自己的方法——列表解析。列表解析来自于函数式编程Haskell。它是一种非常有用、简单、而且灵活的工具，可以用来动态地创建列表。</p>
<p>因为Python支持函数式编程特性，所以类似map()、filter()、reduce()之类的方法可以通过列表解析，简化成一个列表解析式子。</p>
<p>列表解析的语法：</p>
<p><strong>[expr for iter_var in iterable]</strong></p>
<p> 该语法的核心在于for循环，它迭代iterable对象的所有条目，expr应用于序列的每个成员，最后的结果值应该是该表达式产生的列表。</p>
<pre><code># 求0-9的平方和
&gt;&gt;&gt; [x ** 2 for x in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre><p>此外，还有一个类似的拓展版本较为常用 <strong>[expr for iter_var in iterable if cond_expr]</strong></p>
<pre><code># 求0-9的平方和为偶数的数值
&gt;&gt;&gt; [x ** 2 for x in range(10) if x % 2 == 0]
[0, 4, 16, 36, 64]
</code></pre><h4 id="u5E38_u7528_u51FD_u6570_u5F0F_u7F16_u7A0B_u5DE5_u5177"><a href="#u5E38_u7528_u51FD_u6570_u5F0F_u7F16_u7A0B_u5DE5_u5177" class="headerlink" title="常用函数式编程工具"></a>常用函数式编程工具</h4><ul>
<li>filter(function,sequence)方法是返回一个sequence(序列)，包括了给定序列中所有调用function(item)后返回值为true的元素。</li>
</ul>
<p>代码：</p>
<pre><code>&gt;&gt;&gt; def div_3_or_div_5(x):
    return x % 3 == 0 or x % 5 == 0

&gt;&gt;&gt; filter(div_3_or_div_5,range(0,21))
[0, 3, 5, 6, 9, 10, 12, 15, 18, 20]
</code></pre><ul>
<li>map(function,sequence)方法是为每一个元素调用function(item)并将返回值组成一个新的列表返回。</li>
</ul>
<p>代码：</p>
<pre><code>&gt;&gt;&gt; def cube(x):
    return x * x * x

&gt;&gt;&gt; map(cube,range(0,4))
[0, 1, 8, 27]
</code></pre><ul>
<li>reduce(function,sequence)方法是返回一个单值，他的构造方法是：首先以序列的前两个元素调用函数function，再以返回值和第三个参数调用，依次下去。</li>
</ul>
<p>代码：</p>
<pre><code>&gt;&gt;&gt; def sum(seq):
        def add(x, y):
            return x + y
        return reduce(add, seq, 0)

&gt;&gt;&gt; sum(range(1,101))
5050
</code></pre><h3 id="u5185_u5EFA_u51FD_u6570"><a href="#u5185_u5EFA_u51FD_u6570" class="headerlink" title="内建函数"></a>内建函数</h3><p>对于cmp()、len()、max()、min()、enumerate()以及zip()方法和字符串中的使用相同，在这里就不做具体说明了。</p>
<h4 id="u5E8F_u5217_u7C7B_u578B_u51FD_u6570"><a href="#u5E8F_u5217_u7C7B_u578B_u51FD_u6570" class="headerlink" title="序列类型函数"></a>序列类型函数</h4><p>sorted()方法可以实现以ASCII码值大小来排序列表中的成员。</p>
<pre><code>&gt;&gt;&gt; aList = [&apos;cool&apos;,&apos;is&apos;,&apos;Python&apos;]
&gt;&gt;&gt; sorted(aList)
[&apos;Python&apos;, &apos;cool&apos;, &apos;is&apos;]
</code></pre><p>reversed()方法可以实现列表的反转。</p>
<pre><code>&gt;&gt;&gt; aList = [&apos;cool&apos;,&apos;is&apos;,&apos;Python&apos;]
&gt;&gt;&gt; for x in reversed(alist):
    print x,


Python is cool
</code></pre><h4 id="u5217_u8868_u7C7B_u578B_u7684_u5185_u5EFA_u51FD_u6570"><a href="#u5217_u8868_u7C7B_u578B_u7684_u5185_u5EFA_u51FD_u6570" class="headerlink" title="列表类型的内建函数"></a>列表类型的内建函数</h4><ul>
<li>list.append(x)方法是把一个元素添加到链表的结尾</li>
<li>list.insert(index,x)方法是在指定位置插入一个元素</li>
<li>list.remove(x)方法是删除列表中值为x的元素</li>
<li>list.pop([index])方法是删除列表中索引为index的元素</li>
<li>list.count(obj)返回一个对象在列表中出现的次数</li>
<li>list.extend(seq)把序列seq的内容添加到列表中</li>
<li>list.reverse()原地反转列表</li>
<li>list.sort(func=None,key=None,reverse=False)以指定的方式排序列表中的成员，如果func和key参数指定，则按照指定的方式比较各个元素，如果reverse标志置为True，则列表以反序排列。</li>
</ul>
<h2 id="u5217_u8868_u7684_u7279_u6B8A_u7279_u6027"><a href="#u5217_u8868_u7684_u7279_u6B8A_u7279_u6027" class="headerlink" title="列表的特殊特性"></a>列表的特殊特性</h2><p>因为列表是有容器和可变的特性，所以我们经常用它来创建Python数据结构中的堆栈和队列。</p>
<h3 id="u5806_u6808_u7684_u5B9E_u73B0"><a href="#u5806_u6808_u7684_u5B9E_u73B0" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h3><p>堆栈的实现方式主要为“先进后出”，类似于我们清洗饭后的碗碟。</p>
<p>源代码：</p>
<pre><code>class Stack():
    def __init__(self,size):
        self.list = []
        self.size = size
        self.top = -1
    def _Full(self):
        if self.top == self.size - 1:
            return True
        else:
            return False
    def _Empty(self):
        if self.top == -1:
            return True
        else:
            return False
    def instack(self,_list):
        if self._Full():
            print &apos;The stack is Full.&apos;
        else:
            self.list.append(_list)
            self.top = self.top + 1
    def outstack(self):
        if self._Empty():
            print &apos;The stack is empty.!&apos;
        else:
            self.list.pop()
            self.top = self.top - 1
# test

s = Stack(10)
print s._Full()
print s._Empty()
for i in range(10):
    s.instack(i)
print s._Full()
for i in range(10):
    s.outstack()
print s._Empty()
</code></pre><h3 id="u961F_u5217_u7684_u5B9E_u73B0"><a href="#u961F_u5217_u7684_u5B9E_u73B0" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>队列的实现方式主要为“先进先出”，类似于我们生活中排队。</p>
<p>源代码：</p>
<pre><code>class Queue():
    def __init__(self,size):
        self.list = []
        self.size = size
        self.front = -1
        self.rear = -1
    def _Empty(self):
        if self.front == self.rear:
            return True
        else:
            return False
    def _Full(self):
        if self.rear - self.front + 1 == self.size:
            return True
        else:
            return False
    def inqueue(self,_list):
        if self._Full():
            print &apos;The Queue is full.&apos;
        else:
            self.list.append(_list)
            self.rear = self.rear + 1
    def outqueue(self):
        if self._Empty():
            print &apos;The Queue is empty.&apos;
        else:
            self.list.pop()
            self.front = self.front + 1
#test

q = Queue(10)
print q._Empty()
print q._Full()
for i in range(10):
    q.inqueue(i)
print q._Full()
for i in range(10):
    q.outqueue()
print q._Empty()
</code></pre><p>堆栈和队列的容器均之所以选择列表list，而不选择元组tuple,主要是因为列表具有可以进行动态修改，元组不允许修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>列表类型也是序列式的数据类型。和字符串类型一样，可以通过下标或者切片操作来访问一个或者一段连续的元素。不同的是，字符串是不可变的，而列表具有可变容器的特性，使用起来比较灵活，列表容器的元素的数据类型可以是任意类型。</p>
<h1 id="u5217_u8868_28lis]]>
    </summary>
    
      <category term="列表" scheme="http://dsljlbaby.github.io/tags/%E5%88%97%E8%A1%A8/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之字符串]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/31/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://dsljlbaby.github.io/2016/01/31/Python学习笔记之字符串/</id>
    <published>2016-01-31T05:22:45.000Z</published>
    <updated>2016-01-31T09:10:58.795Z</updated>
    <content type="html"><![CDATA[<p>字符串是Python中常见的数据类型，在Python中，可以通过单引号或者双引号来创建字符串，它们的作用是一样的，但在其他编程语言中有所不同，如C语言中使用单引号来创建字符，使用双引号来创建字符串。</p>
<h1 id="u5B57_u7B26_u4E32"><a href="#u5B57_u7B26_u4E32" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是Python中常见的数据类型，在Python中，可以通过单引号或者双引号来创建字符串，它们的作用是一样的，但在其他编程语言中有所不同，如C语言中使用单引号来创建字符，使用双引号来创建字符串。字符串是一种不可变的序列，而列表属于一种可变的序列，元组和字符串一样也是一种不可变的序列。字符串是由独立的字符构成的，我们可以通过切片操作顺序地访问。</p>
<h2 id="u5B57_u7B26_u4E32_u7684_u521B_u5EFA"><a href="#u5B57_u7B26_u4E32_u7684_u521B_u5EFA" class="headerlink" title="字符串的创建"></a>字符串的创建</h2><p>我们可以使用单引号或者双引号来创建一个新的字符串，还可以使用str()将任何一种类型的数据转换成字符串。</p>
<pre><code>string1 = &quot;Hello,Word!&quot;  # 使用双引号
string2 = &apos;Python is good!&apos;  # 使用单引号
string3 = str(range(10))  # 使用str()
</code></pre><h2 id="u5B57_u7B26_u4E32_u7684_u8BBF_u95EE"><a href="#u5B57_u7B26_u4E32_u7684_u8BBF_u95EE" class="headerlink" title="字符串的访问"></a>字符串的访问</h2><p>我们通常使用操作符string[index]、切片操作符string[start_index:end_index]和string[start_index:end_index:num]来对一个字符串的访问。</p>
<pre><code>string2 = &apos;Python is good!&apos;
print string2[3]
print string2[2:9]
print string2[2:9:2]
</code></pre><h2 id="u5B57_u7B26_u4E32_u7684_u4FEE_u6539"><a href="#u5B57_u7B26_u4E32_u7684_u4FEE_u6539" class="headerlink" title="字符串的修改"></a>字符串的修改</h2><p>字符串是一种不可变的序列，我们无法对一个字符串的某个元素进行修改或者删除，我们只能通过创建新的字符串来修改它。我们可以使用赋一个空字符串或者使用del语句进行删除一个字符串。</p>
<pre><code>string1 = &quot;Hello,Word!&quot;
string1 = &apos; &apos;  # 使用空字符串
del string1   #使用del语句
</code></pre><h2 id="u5B57_u7B26_u4E32_u7684_u8FD0_u7B97"><a href="#u5B57_u7B26_u4E32_u7684_u8FD0_u7B97" class="headerlink" title="字符串的运算"></a>字符串的运算</h2><p>我们可以使用标准类型操作符(&lt;,&gt;,&lt;=,&gt;=,!=,==,and,not,or)对两个字符串进行逻辑运算，得到的将会是一个布尔值True/False。</p>
<pre><code>&gt;&gt;&gt; str1 = &apos;abc&apos;
&gt;&gt;&gt; str2 = &apos;xyz&apos;
&gt;&gt;&gt; str3 = &apos;ABC&apos;
&gt;&gt;&gt; str1 == str3  
False
&gt;&gt;&gt; str1 &lt; str2 and str1 == str3
False
&gt;&gt;&gt; str1 &gt; str3
True
</code></pre><p>注意：在做比较操作时，字符串是按照ASCII值的大小进行比较的</p>
<h2 id="u5B57_u7B26_u4E32_u7C7B_u578B_u64CD_u4F5C_u7B26"><a href="#u5B57_u7B26_u4E32_u7C7B_u578B_u64CD_u4F5C_u7B26" class="headerlink" title="字符串类型操作符"></a>字符串类型操作符</h2><p>因为字符串是属于序列的一类，所以序列中常见的操作符（成员关系操作符（in 、not in）、连接操作符（+）、重复操作符（*）、切片操作符（[]、[:]、[::]））都适用于字符串。</p>
<h3 id="u539F_u59CB_u5B57_u7B26_u4E32_u64CD_u4F5C_u7B26_uFF08r/R_uFF09"><a href="#u539F_u59CB_u5B57_u7B26_u4E32_u64CD_u4F5C_u7B26_uFF08r/R_uFF09" class="headerlink" title="原始字符串操作符（r/R）"></a>原始字符串操作符（r/R）</h3><p>在原始字符串里，所有的字符串都是按照字面的意思来使用的，没有转义特殊或者不能打印的字符，这种表现方式很方便我们对程序的调试和正则表达式的创建。</p>
<pre><code>&gt;&gt;&gt; &apos;\n&apos;
&apos;\n&apos;
&gt;&gt;&gt; r&apos;\n&apos;
&apos;\\n&apos;
&gt;&gt;&gt; print &apos;\n&apos; # 下面之出现两个空行，是因为除了换行符之外，print还存在一个换行符


&gt;&gt;&gt; print r&apos;\n&apos; # 打印换行符，不对其进行转义
\n
</code></pre><h3 id="Unicode_u5B57_u7B26_u4E32_u64CD_u4F5C_u7B26_uFF08u/U_uFF09"><a href="#Unicode_u5B57_u7B26_u4E32_u64CD_u4F5C_u7B26_uFF08u/U_uFF09" class="headerlink" title="Unicode字符串操作符（u/U）"></a>Unicode字符串操作符（u/U）</h3><p>Unicode字符串操作符是用来把标准字符串转化成Unicode字符串对象的。</p>
<h4 id="Unicode_u7684_u7B80_u5355_u4E86_u89E3"><a href="#Unicode_u7684_u7B80_u5355_u4E86_u89E3" class="headerlink" title="Unicode的简单了解"></a>Unicode的简单了解</h4><p>起初，我们计算机编码是采用ASCII编码，ASCII码虽然简单，但是可用范围小（32-126），每个英文字符都是以7位二进制的方式储存在计算机中的，尽管后来，软件厂商将ASCII码拓展为8位的，但是面对成千上万的非欧洲语系的语言来说仍然很少。Unicode通过使用一个或者多个字节来表示一个字符的方法实现了可以超过90000个字符的表示。<br>Python中内建函数str()和char()只能处理常规的ASCII编码字符串。如果一个Unicode字符串作为参数传给str()函数，它首先会转换成为ASCII字符串然后进行操作，如果超过了它的处理范围就会出错。针对Unicode出现的unicode()和unichar()表现出更强大的处理功能。<br>Unicode支持多种编码格式。</p>
<h4 id="u5185_u5EFA_u7684decode_28_29/encode_28_29_u65B9_u6CD5"><a href="#u5185_u5EFA_u7684decode_28_29/encode_28_29_u65B9_u6CD5" class="headerlink" title="内建的decode()/encode()方法"></a>内建的decode()/encode()方法</h4><p>decode()和encode()内建函数接收一个字符串做参数返回该字符串对应的编码后/解码后的字符串<br>下面的代码创建了一个Unicode字符串，用UTF-8编码器将它编码，然后写入一个文件，接着把数据从文件中读取出来，解码成Unicode字符串对象，最后打印出来。</p>
<pre><code>CODEC = &apos;utf-8&apos;  # 8位UTF转化格式（无符号字节序列，长度为1-4字节）
filename = &apos;unicode.txt&apos;
hello_out = u&apos;Hello,World!&apos;
bytes_out = hello_out.encode(CODEC)
f = open(filename,&apos;w&apos;)
f.write(bytes_out)
f.close()

f = open(filename)
bytes_in = f.read()
f.close()
hello_in = bytes_in.decode(CODEC)
print hello_in
</code></pre><h3 id="u5185_u5EFA_u51FD_u6570"><a href="#u5185_u5EFA_u51FD_u6570" class="headerlink" title="内建函数"></a>内建函数</h3><h4 id="u6807_u51C6_u7C7B_u578B_u51FD_u6570"><a href="#u6807_u51C6_u7C7B_u578B_u51FD_u6570" class="headerlink" title="标准类型函数"></a>标准类型函数</h4><p>cmp()和比较操作符相似，根据字符串的ASCII码值进行比较,当两个字符床相等时，返回0,大于时返回1，小于时返回-1.</p>
<pre><code>&gt;&gt;&gt; str1 = &apos;abc&apos;
&gt;&gt;&gt; str2 = &apos;ABC&apos;
&gt;&gt;&gt; str3 = &apos;xyz&apos;
&gt;&gt;&gt; cmp(str1,str2)
1
&gt;&gt;&gt; cmp(str2,str3)
-1
&gt;&gt;&gt; cmp(str1,&apos;abc&apos;)
0
</code></pre><h4 id="u5E8F_u5217_u7C7B_u578B_u51FD_u6570"><a href="#u5E8F_u5217_u7C7B_u578B_u51FD_u6570" class="headerlink" title="序列类型函数"></a>序列类型函数</h4><p>len()返回一个字符串的字符数。<br>max()返回一个字符串的最大字符。<br>min()返回一个字符串的最小字符。<br>enumerate()将一个字符串转化成字典形式。</p>
<pre><code>&gt;&gt;&gt; str1 = &apos;foobar&apos;
&gt;&gt;&gt; len(str1)
6
&gt;&gt;&gt; max(str1)
&apos;r&apos;
&gt;&gt;&gt; min(str1)
&apos;a&apos;
&gt;&gt;&gt; for key,value in enumerate(str1):
    print key,value

0 f
1 o
2 o
3 b
4 a
5 r
</code></pre><h4 id="u5B57_u7B26_u4E32_u7C7B_u578B_u51FD_u6570"><a href="#u5B57_u7B26_u4E32_u7C7B_u578B_u51FD_u6570" class="headerlink" title="字符串类型函数"></a>字符串类型函数</h4><p>raw_input()函数使用给定字符串提示用户输入并将这个输入返回。</p>
<pre><code>&gt;&gt;&gt; username = raw_input(&quot;Please enter your name:&quot;)
Please enter your name:Joe
&gt;&gt;&gt; print &quot;Hello,%s&quot; % username
Hello,Joe
</code></pre><p>str()和unicode()函数都可以接受一个任意类型的对象，然后创建该对象的可打印的或Unicode的字符串表示。str()函数将接收的对象首先转化成ASCII码，然后对其操作。它们都可以作为参数传给isinstance()函数来判断一个对象的类型。</p>
<pre><code>&gt;&gt;&gt; isinstance(u&apos;\0xAB&apos;,str)
False
&gt;&gt;&gt; isinstance(&apos;foobar&apos;,str)
True
&gt;&gt;&gt; isinstance(u&apos;\0xAB&apos;,unicode)
True
&gt;&gt;&gt; isinstance(&apos;foobar&apos;,unicode)
False
</code></pre><p>chr()函数用于一个范围在0-255内的整数作为参数，返回对应的字符。<br>unichr()函数和chr()函数类似，只不过返回的是Unicode字符。<br>ord()函数以一个字符作为参数，返回对应的ASCII数值或者Unicode数值。</p>
<pre><code>&gt;&gt;&gt; chr(65)
&apos;A&apos;
&gt;&gt;&gt; ord(&apos;A&apos;)
65
&gt;&gt;&gt; unichr(1234)
u&apos;\u04d2&apos;
&gt;&gt;&gt; ord(u&apos;\u04d2&apos;)
1234
</code></pre><h3 id="u5B57_u7B26_u4E32_u5185_u5EFA_u51FD_u6570"><a href="#u5B57_u7B26_u4E32_u5185_u5EFA_u51FD_u6570" class="headerlink" title="字符串内建函数"></a>字符串内建函数</h3><ul>
<li>string.count(str,beg=0,end=len(string)) 返回str在字符串string中出现的次数</li>
<li>string.find(str,beg=0,end=len(string)) 检测str是否存在字符串string中，存在返回索引值，否则返回-1</li>
<li>string.isalnum() 判断字符串中是否全部为数字或字母</li>
<li>string.isalpha() 判断字符串中是否全部为字母</li>
<li>string.islower() 判断字符串中是否全部为小写字母</li>
<li>string.isupper() 判断字符串中是否全部为大写字母</li>
<li>string.join(seq) 以string作为分隔符，将seq中所有的元素（字符串表示）合并成新的字符串</li>
<li>string.lower() 将字符串中的大写字母全部转成小写字母</li>
<li>string.upper() 将字符串中的小写字母全部转成大写字母</li>
<li>string.strip() 删除字符串中的空格，与string.lstrip()、strng.rstrip()相似</li>
</ul>
<p>代码：</p>
<pre><code>&gt;&gt;&gt; string1 = &apos;Python&apos;
&gt;&gt;&gt; string2 = &apos;Python2.7&apos;
&gt;&gt;&gt; string3 = &apos;123&apos;
&gt;&gt;&gt; string4 = &apos;Python is cool!&apos;
&gt;&gt;&gt; string4.count(&apos;o&apos;)
3
&gt;&gt;&gt; string4.find(&apos;Python&apos;)
0
&gt;&gt;&gt; string3.find(&apos;Python&apos;)
-1
&gt;&gt;&gt; string1.isalnum()
True
&gt;&gt;&gt; string2.isalnum()
False
&gt;&gt;&gt; string3.isalnum()
True
&gt;&gt;&gt; string1.isalpha()
True
&gt;&gt;&gt; string3.isalpha()
False
&gt;&gt;&gt; string1.islower()
False
&gt;&gt;&gt; string2.isupper()
False
&gt;&gt;&gt; string1.join(string3)
&apos;1Python2Python3&apos;
&gt;&gt;&gt; string3.join(string1)
&apos;P123y123t123h123o123n&apos;
&gt;&gt;&gt; string1.lower()
&apos;python&apos;
&gt;&gt;&gt; string1.lower().islower()
True
&gt;&gt;&gt; string1.upper()
&apos;PYTHON&apos;
&gt;&gt;&gt; string1.upper().isupper()
True
&gt;&gt;&gt; string4.strip()
&apos;Python is cool!&apos;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>字符串是Python中常见的数据类型，在Python中，可以通过单引号或者双引号来创建字符串，它们的作用是一样的，但在其他编程语言中有所不同，如C语言中使用单引号来创建字符，使用双引号来创建字符串。</p>
<h1 id="u5B57_u7B26_u4E32"><a hre]]>
    </summary>
    
      <category term="字符串" scheme="http://dsljlbaby.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之序列]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/31/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BA%8F%E5%88%97/"/>
    <id>http://dsljlbaby.github.io/2016/01/31/Python学习笔记之序列/</id>
    <published>2016-01-31T02:59:45.000Z</published>
    <updated>2016-01-31T05:07:20.552Z</updated>
    <content type="html"><![CDATA[<p> 在Python数据类型中，我们经常会接触到这样一种数据类型，它们的成员是<em>有序排列</em>的，并且能够通过下标偏移量可以访问它的具体的成员，这种Python类型统称为<strong>序列</strong>，序列主要包括<em>字符串、列表和元组</em>。</p>
<h1 id="u5E8F_u5217"><a href="#u5E8F_u5217" class="headerlink" title="序列"></a>序列</h1><p>序列：一种有序排列的、可以通过下标偏移量进行访问的数据类型。下标偏移量是从0开始到总元素数-1，这种访问形式和我们C语言中的数组的访问形式相同。</p>
<h2 id="u5E8F_u5217_u7C7B_u578B_u64CD_u4F5C_u7B26"><a href="#u5E8F_u5217_u7C7B_u578B_u64CD_u4F5C_u7B26" class="headerlink" title="序列类型操作符"></a>序列类型操作符</h2><p>序列类型操作符主要分为成员关系操作符（in 、not in）、连接操作符（+）、重复操作符（*）、切片操作符（[]、[:]、[::]）</p>
<h3 id="u6210_u5458_u5173_u7CFB_u64CD_u4F5C_u7B26_uFF08in_u3001not_in_uFF09"><a href="#u6210_u5458_u5173_u7CFB_u64CD_u4F5C_u7B26_uFF08in_u3001not_in_uFF09" class="headerlink" title="成员关系操作符（in、not in）"></a>成员关系操作符（in、not in）</h3><p>成员关系操作符主要是用来判断一个元素是否属于一个序列的。in/not in操作符的返回值一般来讲是一个布尔值False/True。满足成员关系就返回True，否则返回False。</p>
<p>对象 [not] in 序列</p>
<pre><code>seq = &quot;Hello&quot; # 字符串
&apos;H&apos; in seq  True

number = (1,2,3,4,5) # 元组
2 not in number  False 
</code></pre><h3 id="u8FDE_u63A5_u64CD_u4F5C_u7B26_uFF08+_uFF09"><a href="#u8FDE_u63A5_u64CD_u4F5C_u7B26_uFF08+_uFF09" class="headerlink" title="连接操作符（+）"></a>连接操作符（+）</h3><p>通过这个操作符，我们可以简单地把两个相同类型的序列连接成一个新的序列。</p>
<p>sequeue = sequeue1 + sequeue2</p>
<p>注意：这种操作虽然简单，但是比较占用内存，尽量少使用。</p>
<pre><code>sequeue1 = &quot;Hello&quot;
sequeue2 = &quot; Word!&quot;
sequeue = sequeue1 + sequeue2
print sequeue
</code></pre><h3 id="u91CD_u590D_u64CD_u4F5C_u7B26_uFF08*_uFF09"><a href="#u91CD_u590D_u64CD_u4F5C_u7B26_uFF08*_uFF09" class="headerlink" title="重复操作符（*）"></a>重复操作符（*）</h3><p>如果我们需要一个序列的多份拷贝时，这种操作符比较有用。</p>
<p>sequeue * copy_num</p>
<pre><code># 使用它来做分割线
sequeue = _
sequeue = sequeue * 6
print sequeue 
</code></pre><h3 id="u64CD_u4F5C_u7B26_uFF08_5B_5D_u3001_5B_3A_5D_u3001_5B_3A_3A_5D_uFF09"><a href="#u64CD_u4F5C_u7B26_uFF08_5B_5D_u3001_5B_3A_5D_u3001_5B_3A_3A_5D_uFF09" class="headerlink" title="操作符（[]、[:]、[::]）"></a>操作符（[]、[:]、[::]）</h3><p>序列类型就是包含一些顺序排列的对象的一个结构。我们可以使用[]加下标偏移量来访问一个元素或者[start_index:end_index]访问连续的几个元素或使用[start_index:end_index:num]来间隔num个元素访问序列。</p>
<h4 id="u64CD_u4F5C_u7B26_5B_5D"><a href="#u64CD_u4F5C_u7B26_5B_5D" class="headerlink" title="操作符[]"></a>操作符[]</h4><p>使用这种操作符只能访问一个元素。</p>
<p>sequeue[index]</p>
<p>注意：index是想要访问元素的下标偏移量，偏移量既可以为正，也可以为负。它们的区别在于正索引以序列的开始为起点，负索引是以序列的结束为起点。在使用过程尽量避免访问一个越界的索引，它会引发异常。 </p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
print names[0] 

print names[6] # 这是一个越界的索引
Traceback (most recent call last):
   File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;
     print names[6]
IndexError: list index out of range
</code></pre><h4 id="u5207_u7247_u64CD_u4F5C_u7B26_5B_3A_5D"><a href="#u5207_u7247_u64CD_u4F5C_u7B26_5B_3A_5D" class="headerlink" title="切片操作符[:]"></a>切片操作符[:]</h4><p>当我们需要同时获取多个元素时，操作符[]就有点力不从心了，虽然它可以实现，但是代码太丑陋了，所以我们就得寻找新的操作符[:]来解决问题。</p>
<p>sequeue[start_index:end_index]</p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
print names[2:4]
# result
[&apos;Faye&apos;,&apos;Ammy&apos;]
</code></pre><p>如果我们没有提供任何的起始索引和结束索引，它就会访问整个序列。</p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
# 这种方法和names[0:6]是一样的结果
print names[:]  
# result
[&apos;Dava&apos;, &apos;Joe&apos;, &apos;Faye&apos;, &apos;Ammy&apos;, &apos;Frakle&apos;, &apos;Talor&apos;]
</code></pre><p>如果我们只是提过起始索引或者结束索引，如果我们只提供起始索引，它会返回从起始索引到index-1的所有元素，如果我们只提供结束索引，它会返回从索引为0到结束索引的元素。</p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
# 我们只给了起始索引
print names[2:]
# result
[&apos;Faye&apos;, &apos;Ammy&apos;, &apos;Frakle&apos;, &apos;Talor&apos;]
# 我们只给了结束索引
print names[:3]
# result
[&apos;Dava&apos;, &apos;Joe&apos;, &apos;Faye&apos;]
</code></pre><h4 id="u5207_u7247_u64CD_u4F5C_u7B26_5B_3A_3A_5D"><a href="#u5207_u7247_u64CD_u4F5C_u7B26_5B_3A_3A_5D" class="headerlink" title="切片操作符[::]"></a>切片操作符[::]</h4><p>操作符[::]比操作符[:]多出来的第三个索引值是用做步长参数的，它和range()里面的步长参数功能相似。</p>
<p>[start_index:end_index:num]</p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
# 隔一个取一个
print names[2:6:2] 
# result
[&apos;Faye&apos;, &apos;Frakle&apos;]
</code></pre><p>注意：在序列的操作过程中，我们的打印结果是不包括结束索引所对应的那个元素的。切片索引的语法要比单一元素索引灵活得多，开始和结束索引值可以超过字符串的长度。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在Python数据类型中，我们经常会接触到这样一种数据类型，它们的成员是<em>有序排列</em>的，并且能够通过下标偏移量可以访问它的具体的成员，这种Python类型统称为<strong>序列</strong>，序列主要包括<em>字符串、列表和元组</em>。</p>]]>
    </summary>
    
      <category term="序列" scheme="http://dsljlbaby.github.io/tags/%E5%BA%8F%E5%88%97/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(四)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/16/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%9B/"/>
    <id>http://dsljlbaby.github.io/2016/01/16/Python数据结构-四/</id>
    <published>2016-01-16T02:10:58.000Z</published>
    <updated>2016-01-16T02:31:43.618Z</updated>
    <content type="html"><![CDATA[<h2 id="u56FE"><a href="#u56FE" class="headerlink" title="图"></a>图</h2><p>图是由边或者弧连接起来的节点的网络。在有向图中，节点之间的连接是有方向的，叫做弧(arcs)。在无向图中，节点间的连接没有方向，叫做边(edge)。图算法包括查找两点间路径、两点间的最短路径、判断一个图中是否存在环(环是从一个节点可以沿一条非空路径回到它自己)、找到可以遍历所有节点的路径(著名的TSP问题，即旅行商问题)等等</p>
<h2 id="u56FE_u7684_u5B9E_u73B0"><a href="#u56FE_u7684_u5B9E_u73B0" class="headerlink" title="图的实现"></a>图的实现</h2><p>在Python中，图主要是通过列表和词典来构造。比如说下面这张图，</p>
<pre><code>A --&gt; B
A --&gt; C
B --&gt; C
B --&gt; D
C --&gt; D
D --&gt; C
E --&gt; F
F --&gt; C
</code></pre><p>就是通过下面这个字典和列表的结合进行构造</p>
<pre><code>graph = {&apos;A&apos;: [&apos;B&apos;, &apos;C&apos;],
         &apos;B&apos;: [&apos;C&apos;, &apos;D&apos;],
         &apos;C&apos;: [&apos;D&apos;],
         &apos;D&apos;: [&apos;C&apos;],
         &apos;E&apos;: [&apos;F&apos;],
         &apos;F&apos;: [&apos;C&apos;]}
</code></pre><h2 id="u6E90_u4EE3_u7801"><a href="#u6E90_u4EE3_u7801" class="headerlink" title="源代码"></a>源代码</h2><pre><code># -*- encoding:utf-8 -*-
&apos;&apos;&apos;

 A --&gt; B
 A --&gt; C
 B --&gt; C
 B --&gt; D
 C --&gt; D
 D --&gt; C
 E --&gt; F
 F --&gt; C

&apos;&apos;&apos;


def find_path(graph, start, end, path=[]):
        &apos;寻找一条路径&apos;
        path = path + [start]
        if start == end:
            return path
        if not graph.has_key(start):
            return None
        for node in graph[start]:
            if node not in path:
                newpath = find_path(graph, node, end, path)
                if newpath:
                    return newpath
        return path

def find_all_paths(graph, start, end, path=[]):
        &apos;查找所有的路径&apos;
        path = path + [start]
        if start == end:
            return [path]
        if not graph.has_key(start):
            return []
        paths = []
        for node in graph[start]:
            if node not in path:
                newpaths = find_all_paths(graph, node, end, path)
                for newpath in newpaths:
                    paths.append(newpath)
        return paths

def find_shortest_path(graph, start, end, path=[]):
        &apos;查找最短路径&apos;
        path = path + [start]
        if start == end:
            return path
        if not graph.has_key(start):
            return None
        shortest = None
        for node in graph[start]:
            if node not in path:
                newpath = find_shortest_path(graph, node, end, path)
                if newpath:
                    if not shortest or len(newpath) &lt; len(shortest):
                        shortest = newpath
        return shortest

#test

if __name__ == &apos;__main__&apos;:
    graph = {&apos;A&apos;: [&apos;B&apos;, &apos;C&apos;],
             &apos;B&apos;: [&apos;C&apos;, &apos;D&apos;],
             &apos;C&apos;: [&apos;D&apos;],
             &apos;D&apos;: [&apos;C&apos;],
             &apos;E&apos;: [&apos;F&apos;],
             &apos;F&apos;: [&apos;C&apos;]}
    print find_path(graph,&apos;A&apos;,&apos;D&apos;)
    print find_all_paths(graph,&apos;A&apos;,&apos;D&apos;)
    print find_shortest_path(graph,&apos;A&apos;,&apos;D&apos;)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u56FE"><a href="#u56FE" class="headerlink" title="图"></a>图</h2><p>图是由边或者弧连接起来的节点的网络。在有向图中，节点之间的连接是有方向的，叫做弧(arcs)。在无向图中，节点间的连接没有方向，叫做]]>
    </summary>
    
      <category term="图" scheme="http://dsljlbaby.github.io/tags/%E5%9B%BE/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(三)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/15/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%89/"/>
    <id>http://dsljlbaby.github.io/2016/01/15/Python数据结构-三/</id>
    <published>2016-01-15T02:18:04.000Z</published>
    <updated>2016-01-15T02:50:17.445Z</updated>
    <content type="html"><![CDATA[<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>bitmap是很常用的数据结构，比如用于Bloom Filter中；用于无重复整数的排序等等。bitmap通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。</p>
<h3 id="Bitmap_u7684_u5B9A_u4E49"><a href="#Bitmap_u7684_u5B9A_u4E49" class="headerlink" title="Bitmap的定义"></a>Bitmap的定义</h3><p>bitmap是很常用的数据结构，比如用于Bloom Filter中；用于无重复整数的排序等等。bitmap通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。简单的来说，这种数据结构存储把原来的数转化成二进制储存，每一位占一个储存单元，我们操作bimap中的数据，就相当于操作一个位。对于Python来说，整数类型默认是有符号类型，所以一个整数的可用位数为31位。</p>
<h3 id="Bitmap_u7684_u64CD_u4F5C"><a href="#Bitmap_u7684_u64CD_u4F5C" class="headerlink" title="Bitmap的操作"></a>Bitmap的操作</h3><p>如果我们想操作某一位数，要先获取到操作数组的第几个元素，再获取相应的位索引，然后执行操作。操作的过程大致分为初始化bitmap、计算在数组中的索引、计算在数组中的位索引、相关位置1、测试相关位。</p>
<h4 id="u521D_u59CB_u5316bitmap"><a href="#u521D_u59CB_u5316bitmap" class="headerlink" title="初始化bitmap"></a>初始化bitmap</h4><p>初始化bitmap也就是计算所需数组的大小，通常采用对最大数向上取整的方法，如果可以找到储存最大数的数组，那么其他数就不成问题了。</p>
<pre><code>class Bitmap():
    def __init__(self,max):
    self.size = int ((max + 31 - 1) / 31) #max需要传入的为要排序的最大数
</code></pre><h4 id="u8BA1_u7B97_u5728_u6570_u7EC4_u4E2D_u7684_u7D22_u5F15"><a href="#u8BA1_u7B97_u5728_u6570_u7EC4_u4E2D_u7684_u7D22_u5F15" class="headerlink" title="计算在数组中的索引"></a>计算在数组中的索引</h4><p>计算在数组中的索引与初始化btimap不同的是采用向下取整的方法，其他相同。</p>
<h4 id="u8BA1_u7B97_u5728_u6570_u7EC4_u4E2D_u7684_u4F4D_u7D22_u5F15"><a href="#u8BA1_u7B97_u5728_u6570_u7EC4_u4E2D_u7684_u4F4D_u7D22_u5F15" class="headerlink" title="计算在数组中的位索引"></a>计算在数组中的位索引</h4><p>数组元素中的位索引可以通过取模运算来得到。令需存储的整数跟31取模即可得到位索引</p>
<pre><code>def bitindex(self,num):
    return num % 31
</code></pre><h4 id="u76F8_u5173_u4F4D_u7F6E1"><a href="#u76F8_u5173_u4F4D_u7F6E1" class="headerlink" title="相关位置1"></a>相关位置1</h4><p>二进制位默认是0，将某位置1则表示在此位存储了数据</p>
<pre><code>def set_1(self,num):
    elemindex = num / 31
    byteindex = self.bitindex(num)
    ele = self.array[elemindex]
    self.array[elemindex] = ele | (1 &lt;&lt; byteindex)
</code></pre><h4 id="u6D4B_u8BD5_u76F8_u5173_u4F4D"><a href="#u6D4B_u8BD5_u76F8_u5173_u4F4D" class="headerlink" title="测试相关位"></a>测试相关位</h4><p>判断某位是否为1是为了取出之前所存储的数据</p>
<pre><code>def test_1(self,i):
    elemindex = i / 31
    byteindex = self.bitindex(i)
    if self.array[elemindex] &amp; (1 &lt;&lt; byteindex):
        return True
    return False
</code></pre><h3 id="u6E90_u4EE3_u7801"><a href="#u6E90_u4EE3_u7801" class="headerlink" title="源代码"></a>源代码</h3><pre><code># -*- encoding:utf-8 -*-
class Bitmap():
    def __init__(self,max):
        &apos;确定所需数组个数&apos;
        self.size = int ((max + 31 - 1) / 31)
        self.array = [0 for i in range(self.size)]

    def bitindex(self,num):
        &apos;确定数组中元素的位索引&apos;
        return num % 31

    def set_1(self,num):
        &apos;将元素所在的位置1&apos;
        elemindex = num / 31
        byteindex = self.bitindex(num)
        ele = self.array[elemindex]
        self.array[elemindex] = ele | (1 &lt;&lt; byteindex)

    def test_1(self,i):
        &apos;检测元素存在的位置&apos;
        elemindex = i / 31
        byteindex = self.bitindex(i)
        if self.array[elemindex] &amp; (1 &lt;&lt; byteindex):
            return True
        return False
if __name__ == &apos;__main__&apos;:
    Max = ord(&apos;z&apos;)
    suffle_array = [x for x in &apos;qwelmfg&apos;]
    result = []
    bitmap = Bitmap(Max)
    for c in suffle_array:
        bitmap.set_1(ord(c))
    for i in range(Max+1):
        if bitmap.test_1(i):
            result.append(chr(i))
    print u&apos;原始数组为:    %s&apos; % suffle_array
    print u&apos;排序后的数组为: %s&apos; % result
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>bitmap是很常用的数据结构，比如用于Bloom Filter中；用于无重复整数的排序等等。bitmap通]]>
    </summary>
    
      <category term="bitmap" scheme="http://dsljlbaby.github.io/tags/bitmap/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(二)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/14/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C/"/>
    <id>http://dsljlbaby.github.io/2016/01/14/Python数据结构-二/</id>
    <published>2016-01-14T02:28:32.000Z</published>
    <updated>2016-01-14T02:41:19.062Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E8C_u53C9_u6811_u7684_u5B9E_u73B0"><a href="#u4E8C_u53C9_u6811_u7684_u5B9E_u73B0" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><h3 id="u6811_u7684_u5B9A_u4E49"><a href="#u6811_u7684_u5B9A_u4E49" class="headerlink" title="树的定义"></a>树的定义　　</h3><p>　　树是一种重要的非线性数据结构，直观地看，它是数据元素（在树中称为结点）按分支关系组织起来的结构，很象自然界中的树那样。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树形象表示。树在计算机领域中也得到广泛应用，如在编译源程序时，可用树表示源程序的语法结构。又如在数据库系统中，树型结构也是信息的重要组织形式之一。一切具有层次关系的问题都可用树来描述。</p>
<p> 树结构的特点是：它的每一个结点都可以有不止一个直接后继，除根结点外的所有结点都有且只有一个直接前驱。</p>
<p>树的递归定义如下：</p>
<ul>
<li>至少有一个结点（称为根）</li>
<li>其它是互不相交的子树</li>
</ul>
<h3 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是由n（n≥0）个结点组成的有限集合、每个结点最多有两个子树的有序树。它或者是空集，或者是由一个根和称为左、右子树的两个不相交的二叉树组成。</p>
<p>特点：</p>
<ul>
<li>二叉树是有序树，即使只有一个子树，也必须区分左、右子树；</li>
</ul>
<ul>
<li>二叉树的每个结点的度不能大于2，只能取0、1、2三者之一；</li>
</ul>
<ul>
<li>二叉树中所有结点的形态有5种：空结点、无左右子树的结点、只有左子树的结点、只有右子树的结点和具有左右子树的结点。</li>
</ul>
<h3 id="u6E90_u4EE3_u7801_uFF1A"><a href="#u6E90_u4EE3_u7801_uFF1A" class="headerlink" title="源代码："></a>源代码：</h3><pre><code>#-*- encoding:utf-8 -*-

&apos;&apos;&apos;
树的构建：
     5
  6     7
8         9
&apos;&apos;&apos;

class Tree():
   &apos;树的实现&apos;
    def __init__(self,ltree = 0,rtree = 0,data = 0):
        self.ltree = ltree
        self.rtree = rtree
        self.data = data
class BTree():
    &apos;二叉树的实现&apos;
    def __init__(self,base = 0):
        self.base = base
    def _Empty(self):
        &apos;是否为空树&apos;
        if self.base == 0:
            return True
        else:
            return False
    def qout(self,tree_base):
        &apos;前序遍历:根-左-右&apos;
        if tree_base == 0:
            return
        print tree_base.data
        self.qout(tree_base.ltree)
        self.qout(tree_base.rtree)
    def mout(self,tree_base):
        &apos;中序遍历:左-根-右&apos;
        if tree_base == 0:
            return
        self.mout(tree_base.ltree)
        print tree_base.data
        self.mout(tree_base.rtree)
    def hout(self,tree_base):
        &apos;后序遍历:左-右-根&apos;
        if tree_base == 0:
            return
        self.hout(tree_base.ltree)
        self.hout(tree_base.rtree)
        print tree_base.data
#test

tree1 = Tree(data=8)
tree2 = Tree(data=9)
tree3 = Tree(tree1,data=6)
tree4 = Tree(tree2,0,data=7)
base = Tree(tree3,tree4,5)
btree = BTree(base)
print &apos;前序遍历结果:&apos;
btree.qout(btree.base)
print &apos;中序遍历结果:&apos;
btree.mout(btree.base)
print &apos;后序遍历结果:&apos;
btree.hout(btree.base)
</code></pre><h2 id="u94FE_u8868_u7684_u5B9E_u73B0"><a href="#u94FE_u8868_u7684_u5B9E_u73B0" class="headerlink" title="链表的实现"></a>链表的实现</h2><h3 id="u94FE_u8868_u7684_u5B9A_u4E49"><a href="#u94FE_u8868_u7684_u5B9A_u4E49" class="headerlink" title="链表的定义"></a>链表的定义</h3><p>　　链表(linked list)是由一组被称为结点的数据元素组成的数据结构，每个结点都包含结点本身的信息和指向下一个结点的地址。由于每个结点都包含了可以链接起来的地址信息，所以用一个变量就能够访问整个结点序列。也就是说，结点包含两部分信息：一部分用于存储数据元素的值，称为信息域；另一部分用于存储下一个数据元素地址的指针，称为指针域。链表中的第一个结点的地址存储在一个单独的结点中，称为头结点或首结点。链表中的最后一个结点没有后继元素，其指针域为空。</p>
<h3 id="u6E90_u4EE3_u7801"><a href="#u6E90_u4EE3_u7801" class="headerlink" title="源代码"></a>源代码</h3><pre><code># -*- encoding:utf-8 -*-
class Node():
    &apos;创建节点&apos;
    def __init__(self,data):
        self.data = data
        self.next = None

class LinkList():
    &apos;创建列表&apos;
    def __init__(self, node):
        &apos;初始化列表&apos;
        self.head = node
        self.head.next = None
        self.tail = self.head

    def add_node(self, node):
        &apos;添加节点&apos;
        self.tail.next = node
        self.tail = self.tail.next

    def view(self):
        &apos;查看列表&apos;
        node = self.head
        link_str = &apos;&apos;
        while node is not None:
            if node.next is not None:
                link_str += str(node.data) + &apos;--&gt;&apos;
            else:
                link_str += str(node.data)
            node = node.next
        print &apos;The Linklist is:&apos; + link_str

    def length(self):
        &apos;列表长度&apos;
        node = self.head
        count = 1
        while node.next is not None:
            count += 1
            node = node.next
        print &apos;The length of linklist are %d&apos; % count
        return count

    def delete_node(self, index):
        &apos;删除节点&apos;
        if index+1 &gt; self.length():
            raise IndexError(&apos;index out of bounds&apos;)
        num = 0
        node = self.head
        while True:
            if num == index-1:
                break
            node = node.next
            num += 1
        tmp_node = node.next
        node.next = node.next.next
        return tmp_node.data

    def find_node(self, index):
        &apos;查看具体节点&apos;
        if index+1 &gt; self.length():
            raise IndexError(&apos;index out of bounds&apos;)
        num = 0
        node = self.head
        while True:
            if num == index:
                break
            node = node.next
            num += 1
        return node.data

# test

node1 = Node(10)
node2 = Node(&apos;dec&apos;)
node3 = Node(1010)
node4 = Node(&apos;bin&apos;)
node5 = Node(12)
node6 = Node(&apos;oct&apos;)
node7 = Node(&apos;A&apos;)
node8 = Node(&apos;hex&apos;)

linklist = LinkList(node1)
linklist.add_node(node2)
linklist.add_node(node3)
linklist.add_node(node4)
linklist.add_node(node5)
linklist.add_node(node6)
linklist.add_node(node7)
linklist.add_node(node8)

linklist.view()
linklist.length()
linklist.delete_node(1)
linklist.view()
find_node = linklist.find_node(6)
print find_node
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E8C_u53C9_u6811_u7684_u5B9E_u73B0"><a href="#u4E8C_u53C9_u6811_u7684_u5B9E_u73B0" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2]]>
    </summary>
    
      <category term="二叉树" scheme="http://dsljlbaby.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="链表" scheme="http://dsljlbaby.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(一)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/13/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80/"/>
    <id>http://dsljlbaby.github.io/2016/01/13/Python数据结构-一/</id>
    <published>2016-01-13T03:03:18.000Z</published>
    <updated>2016-01-14T02:41:19.063Z</updated>
    <content type="html"><![CDATA[<h3 id="u5806_u6808_u7684_u5B9E_u73B0"><a href="#u5806_u6808_u7684_u5B9E_u73B0" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h3><p>堆栈的实现方式主要为“先进后出”，类似于我们清洗饭后的碗碟。</p>
<h4 id="u6E90_u4EE3_u7801_uFF1A"><a href="#u6E90_u4EE3_u7801_uFF1A" class="headerlink" title="源代码："></a>源代码：</h4><pre><code>class Stack():
    def __init__(self,size):
        self.list = []
        self.size = size
        self.top = -1
    def _Full(self):
        if self.top == self.size - 1:
            return True
        else:
            return False
    def _Empty(self):
        if self.top == -1:
            return True
        else:
            return False
    def instack(self,_list):
        if self._Full():
            print &apos;The stack is Full.&apos;
        else:
            self.list.append(_list)
            self.top = self.top + 1
    def outstack(self):
        if self._Empty():
            print &apos;The stack is empty.!&apos;
        else:
            self.list.pop()
            self.top = self.top - 1
# test

s = Stack(10)
print s._Full()
print s._Empty()
for i in range(10):
    s.instack(i)
print s._Full()
for i in range(10):
    s.outstack()
print s._Empty()
</code></pre><h3 id="u961F_u5217_u7684_u5B9E_u73B0"><a href="#u961F_u5217_u7684_u5B9E_u73B0" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>队列的实现方式主要为“先进先出”，类似于我们生活中排队。</p>
<h4 id="u6E90_u4EE3_u7801_uFF1A-1"><a href="#u6E90_u4EE3_u7801_uFF1A-1" class="headerlink" title="源代码："></a>源代码：</h4><pre><code>class Queue():
    def __init__(self,size):
        self.list = []
        self.size = size
        self.front = -1
        self.rear = -1
    def _Empty(self):
        if self.front == self.rear:
            return True
        else:
            return False
    def _Full(self):
        if self.rear - self.front + 1 == self.size:
            return True
        else:
            return False
    def inqueue(self,_list):
        if self._Full():
            print &apos;The Queue is full.&apos;
        else:
            self.list.append(_list)
            self.rear = self.rear + 1
    def outqueue(self):
        if self._Empty():
            print &apos;The Queue is empty.&apos;
        else:
            self.list.pop()
            self.front = self.front + 1
#test

q = Queue(10)
print q._Empty()
print q._Full()
for i in range(10):
    q.inqueue(i)
print q._Full()
for i in range(10):
    q.outqueue()
print q._Empty()
</code></pre><p>堆栈和队列的容器均之所以选择列表list，而不选择元组tuple,主要是因为列表具有可以进行动态修改，元组不允许修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5806_u6808_u7684_u5B9E_u73B0"><a href="#u5806_u6808_u7684_u5B9E_u73B0" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h3><p>堆栈的实现方式主要为]]>
    </summary>
    
      <category term="堆栈" scheme="http://dsljlbaby.github.io/tags/%E5%A0%86%E6%A0%88/"/>
    
      <category term="队列" scheme="http://dsljlbaby.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
</feed>
