<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Dsljlbaby's Blog]]></title>
  <subtitle><![CDATA[只有行动才能说明一切]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dsljlbaby.github.io/"/>
  <updated>2016-01-31T09:10:58.795Z</updated>
  <id>http://dsljlbaby.github.io/</id>
  
  <author>
    <name><![CDATA[Dsljlbaby]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python学习笔记之字符串]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/31/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://dsljlbaby.github.io/2016/01/31/Python学习笔记之字符串/</id>
    <published>2016-01-31T05:22:45.000Z</published>
    <updated>2016-01-31T09:10:58.795Z</updated>
    <content type="html"><![CDATA[<p>字符串是Python中常见的数据类型，在Python中，可以通过单引号或者双引号来创建字符串，它们的作用是一样的，但在其他编程语言中有所不同，如C语言中使用单引号来创建字符，使用双引号来创建字符串。</p>
<h1 id="u5B57_u7B26_u4E32"><a href="#u5B57_u7B26_u4E32" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是Python中常见的数据类型，在Python中，可以通过单引号或者双引号来创建字符串，它们的作用是一样的，但在其他编程语言中有所不同，如C语言中使用单引号来创建字符，使用双引号来创建字符串。字符串是一种不可变的序列，而列表属于一种可变的序列，元组和字符串一样也是一种不可变的序列。字符串是由独立的字符构成的，我们可以通过切片操作顺序地访问。</p>
<h2 id="u5B57_u7B26_u4E32_u7684_u521B_u5EFA"><a href="#u5B57_u7B26_u4E32_u7684_u521B_u5EFA" class="headerlink" title="字符串的创建"></a>字符串的创建</h2><p>我们可以使用单引号或者双引号来创建一个新的字符串，还可以使用str()将任何一种类型的数据转换成字符串。</p>
<pre><code>string1 = &quot;Hello,Word!&quot;  # 使用双引号
string2 = &apos;Python is good!&apos;  # 使用单引号
string3 = str(range(10))  # 使用str()
</code></pre><h2 id="u5B57_u7B26_u4E32_u7684_u8BBF_u95EE"><a href="#u5B57_u7B26_u4E32_u7684_u8BBF_u95EE" class="headerlink" title="字符串的访问"></a>字符串的访问</h2><p>我们通常使用操作符string[index]、切片操作符string[start_index:end_index]和string[start_index:end_index:num]来对一个字符串的访问。</p>
<pre><code>string2 = &apos;Python is good!&apos;
print string2[3]
print string2[2:9]
print string2[2:9:2]
</code></pre><h2 id="u5B57_u7B26_u4E32_u7684_u4FEE_u6539"><a href="#u5B57_u7B26_u4E32_u7684_u4FEE_u6539" class="headerlink" title="字符串的修改"></a>字符串的修改</h2><p>字符串是一种不可变的序列，我们无法对一个字符串的某个元素进行修改或者删除，我们只能通过创建新的字符串来修改它。我们可以使用赋一个空字符串或者使用del语句进行删除一个字符串。</p>
<pre><code>string1 = &quot;Hello,Word!&quot;
string1 = &apos; &apos;  # 使用空字符串
del string1   #使用del语句
</code></pre><h2 id="u5B57_u7B26_u4E32_u7684_u8FD0_u7B97"><a href="#u5B57_u7B26_u4E32_u7684_u8FD0_u7B97" class="headerlink" title="字符串的运算"></a>字符串的运算</h2><p>我们可以使用标准类型操作符(&lt;,&gt;,&lt;=,&gt;=,!=,==,and,not,or)对两个字符串进行逻辑运算，得到的将会是一个布尔值True/False。</p>
<pre><code>&gt;&gt;&gt; str1 = &apos;abc&apos;
&gt;&gt;&gt; str2 = &apos;xyz&apos;
&gt;&gt;&gt; str3 = &apos;ABC&apos;
&gt;&gt;&gt; str1 == str3  
False
&gt;&gt;&gt; str1 &lt; str2 and str1 == str3
False
&gt;&gt;&gt; str1 &gt; str3
True
</code></pre><p>注意：在做比较操作时，字符串是按照ASCII值的大小进行比较的</p>
<h2 id="u5B57_u7B26_u4E32_u7C7B_u578B_u64CD_u4F5C_u7B26"><a href="#u5B57_u7B26_u4E32_u7C7B_u578B_u64CD_u4F5C_u7B26" class="headerlink" title="字符串类型操作符"></a>字符串类型操作符</h2><p>因为字符串是属于序列的一类，所以序列中常见的操作符（成员关系操作符（in 、not in）、连接操作符（+）、重复操作符（*）、切片操作符（[]、[:]、[::]））都适用于字符串。</p>
<h3 id="u539F_u59CB_u5B57_u7B26_u4E32_u64CD_u4F5C_u7B26_uFF08r/R_uFF09"><a href="#u539F_u59CB_u5B57_u7B26_u4E32_u64CD_u4F5C_u7B26_uFF08r/R_uFF09" class="headerlink" title="原始字符串操作符（r/R）"></a>原始字符串操作符（r/R）</h3><p>在原始字符串里，所有的字符串都是按照字面的意思来使用的，没有转义特殊或者不能打印的字符，这种表现方式很方便我们对程序的调试和正则表达式的创建。</p>
<pre><code>&gt;&gt;&gt; &apos;\n&apos;
&apos;\n&apos;
&gt;&gt;&gt; r&apos;\n&apos;
&apos;\\n&apos;
&gt;&gt;&gt; print &apos;\n&apos; # 下面之出现两个空行，是因为除了换行符之外，print还存在一个换行符


&gt;&gt;&gt; print r&apos;\n&apos; # 打印换行符，不对其进行转义
\n
</code></pre><h3 id="Unicode_u5B57_u7B26_u4E32_u64CD_u4F5C_u7B26_uFF08u/U_uFF09"><a href="#Unicode_u5B57_u7B26_u4E32_u64CD_u4F5C_u7B26_uFF08u/U_uFF09" class="headerlink" title="Unicode字符串操作符（u/U）"></a>Unicode字符串操作符（u/U）</h3><p>Unicode字符串操作符是用来把标准字符串转化成Unicode字符串对象的。</p>
<h4 id="Unicode_u7684_u7B80_u5355_u4E86_u89E3"><a href="#Unicode_u7684_u7B80_u5355_u4E86_u89E3" class="headerlink" title="Unicode的简单了解"></a>Unicode的简单了解</h4><p>起初，我们计算机编码是采用ASCII编码，ASCII码虽然简单，但是可用范围小（32-126），每个英文字符都是以7位二进制的方式储存在计算机中的，尽管后来，软件厂商将ASCII码拓展为8位的，但是面对成千上万的非欧洲语系的语言来说仍然很少。Unicode通过使用一个或者多个字节来表示一个字符的方法实现了可以超过90000个字符的表示。<br>Python中内建函数str()和char()只能处理常规的ASCII编码字符串。如果一个Unicode字符串作为参数传给str()函数，它首先会转换成为ASCII字符串然后进行操作，如果超过了它的处理范围就会出错。针对Unicode出现的unicode()和unichar()表现出更强大的处理功能。<br>Unicode支持多种编码格式。</p>
<h4 id="u5185_u5EFA_u7684decode_28_29/encode_28_29_u65B9_u6CD5"><a href="#u5185_u5EFA_u7684decode_28_29/encode_28_29_u65B9_u6CD5" class="headerlink" title="内建的decode()/encode()方法"></a>内建的decode()/encode()方法</h4><p>decode()和encode()内建函数接收一个字符串做参数返回该字符串对应的编码后/解码后的字符串<br>下面的代码创建了一个Unicode字符串，用UTF-8编码器将它编码，然后写入一个文件，接着把数据从文件中读取出来，解码成Unicode字符串对象，最后打印出来。</p>
<pre><code>CODEC = &apos;utf-8&apos;  # 8位UTF转化格式（无符号字节序列，长度为1-4字节）
filename = &apos;unicode.txt&apos;
hello_out = u&apos;Hello,World!&apos;
bytes_out = hello_out.encode(CODEC)
f = open(filename,&apos;w&apos;)
f.write(bytes_out)
f.close()

f = open(filename)
bytes_in = f.read()
f.close()
hello_in = bytes_in.decode(CODEC)
print hello_in
</code></pre><h3 id="u5185_u5EFA_u51FD_u6570"><a href="#u5185_u5EFA_u51FD_u6570" class="headerlink" title="内建函数"></a>内建函数</h3><h4 id="u6807_u51C6_u7C7B_u578B_u51FD_u6570"><a href="#u6807_u51C6_u7C7B_u578B_u51FD_u6570" class="headerlink" title="标准类型函数"></a>标准类型函数</h4><p>cmp()和比较操作符相似，根据字符串的ASCII码值进行比较,当两个字符床相等时，返回0,大于时返回1，小于时返回-1.</p>
<pre><code>&gt;&gt;&gt; str1 = &apos;abc&apos;
&gt;&gt;&gt; str2 = &apos;ABC&apos;
&gt;&gt;&gt; str3 = &apos;xyz&apos;
&gt;&gt;&gt; cmp(str1,str2)
1
&gt;&gt;&gt; cmp(str2,str3)
-1
&gt;&gt;&gt; cmp(str1,&apos;abc&apos;)
0
</code></pre><h4 id="u5E8F_u5217_u7C7B_u578B_u51FD_u6570"><a href="#u5E8F_u5217_u7C7B_u578B_u51FD_u6570" class="headerlink" title="序列类型函数"></a>序列类型函数</h4><p>len()返回一个字符串的字符数。<br>max()返回一个字符串的最大字符。<br>min()返回一个字符串的最小字符。<br>enumerate()将一个字符串转化成字典形式。</p>
<pre><code>&gt;&gt;&gt; str1 = &apos;foobar&apos;
&gt;&gt;&gt; len(str1)
6
&gt;&gt;&gt; max(str1)
&apos;r&apos;
&gt;&gt;&gt; min(str1)
&apos;a&apos;
&gt;&gt;&gt; for key,value in enumerate(str1):
    print key,value

0 f
1 o
2 o
3 b
4 a
5 r
</code></pre><h4 id="u5B57_u7B26_u4E32_u7C7B_u578B_u51FD_u6570"><a href="#u5B57_u7B26_u4E32_u7C7B_u578B_u51FD_u6570" class="headerlink" title="字符串类型函数"></a>字符串类型函数</h4><p>raw_input()函数使用给定字符串提示用户输入并将这个输入返回。</p>
<pre><code>&gt;&gt;&gt; username = raw_input(&quot;Please enter your name:&quot;)
Please enter your name:Joe
&gt;&gt;&gt; print &quot;Hello,%s&quot; % username
Hello,Joe
</code></pre><p>str()和unicode()函数都可以接受一个任意类型的对象，然后创建该对象的可打印的或Unicode的字符串表示。str()函数将接收的对象首先转化成ASCII码，然后对其操作。它们都可以作为参数传给isinstance()函数来判断一个对象的类型。</p>
<pre><code>&gt;&gt;&gt; isinstance(u&apos;\0xAB&apos;,str)
False
&gt;&gt;&gt; isinstance(&apos;foobar&apos;,str)
True
&gt;&gt;&gt; isinstance(u&apos;\0xAB&apos;,unicode)
True
&gt;&gt;&gt; isinstance(&apos;foobar&apos;,unicode)
False
</code></pre><p>chr()函数用于一个范围在0-255内的整数作为参数，返回对应的字符。<br>unichr()函数和chr()函数类似，只不过返回的是Unicode字符。<br>ord()函数以一个字符作为参数，返回对应的ASCII数值或者Unicode数值。</p>
<pre><code>&gt;&gt;&gt; chr(65)
&apos;A&apos;
&gt;&gt;&gt; ord(&apos;A&apos;)
65
&gt;&gt;&gt; unichr(1234)
u&apos;\u04d2&apos;
&gt;&gt;&gt; ord(u&apos;\u04d2&apos;)
1234
</code></pre><h3 id="u5B57_u7B26_u4E32_u5185_u5EFA_u51FD_u6570"><a href="#u5B57_u7B26_u4E32_u5185_u5EFA_u51FD_u6570" class="headerlink" title="字符串内建函数"></a>字符串内建函数</h3><ul>
<li>string.count(str,beg=0,end=len(string)) 返回str在字符串string中出现的次数</li>
<li>string.find(str,beg=0,end=len(string)) 检测str是否存在字符串string中，存在返回索引值，否则返回-1</li>
<li>string.isalnum() 判断字符串中是否全部为数字或字母</li>
<li>string.isalpha() 判断字符串中是否全部为字母</li>
<li>string.islower() 判断字符串中是否全部为小写字母</li>
<li>string.isupper() 判断字符串中是否全部为大写字母</li>
<li>string.join(seq) 以string作为分隔符，将seq中所有的元素（字符串表示）合并成新的字符串</li>
<li>string.lower() 将字符串中的大写字母全部转成小写字母</li>
<li>string.upper() 将字符串中的小写字母全部转成大写字母</li>
<li>string.strip() 删除字符串中的空格，与string.lstrip()、strng.rstrip()相似</li>
</ul>
<p>代码：</p>
<pre><code>&gt;&gt;&gt; string1 = &apos;Python&apos;
&gt;&gt;&gt; string2 = &apos;Python2.7&apos;
&gt;&gt;&gt; string3 = &apos;123&apos;
&gt;&gt;&gt; string4 = &apos;Python is cool!&apos;
&gt;&gt;&gt; string4.count(&apos;o&apos;)
3
&gt;&gt;&gt; string4.find(&apos;Python&apos;)
0
&gt;&gt;&gt; string3.find(&apos;Python&apos;)
-1
&gt;&gt;&gt; string1.isalnum()
True
&gt;&gt;&gt; string2.isalnum()
False
&gt;&gt;&gt; string3.isalnum()
True
&gt;&gt;&gt; string1.isalpha()
True
&gt;&gt;&gt; string3.isalpha()
False
&gt;&gt;&gt; string1.islower()
False
&gt;&gt;&gt; string2.isupper()
False
&gt;&gt;&gt; string1.join(string3)
&apos;1Python2Python3&apos;
&gt;&gt;&gt; string3.join(string1)
&apos;P123y123t123h123o123n&apos;
&gt;&gt;&gt; string1.lower()
&apos;python&apos;
&gt;&gt;&gt; string1.lower().islower()
True
&gt;&gt;&gt; string1.upper()
&apos;PYTHON&apos;
&gt;&gt;&gt; string1.upper().isupper()
True
&gt;&gt;&gt; string4.strip()
&apos;Python is cool!&apos;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>字符串是Python中常见的数据类型，在Python中，可以通过单引号或者双引号来创建字符串，它们的作用是一样的，但在其他编程语言中有所不同，如C语言中使用单引号来创建字符，使用双引号来创建字符串。</p>
<h1 id="u5B57_u7B26_u4E32"><a hre]]>
    </summary>
    
      <category term="字符串" scheme="http://dsljlbaby.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python学习笔记之序列]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/31/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BA%8F%E5%88%97/"/>
    <id>http://dsljlbaby.github.io/2016/01/31/Python学习笔记之序列/</id>
    <published>2016-01-31T02:59:45.000Z</published>
    <updated>2016-01-31T05:07:20.552Z</updated>
    <content type="html"><![CDATA[<p> 在Python数据类型中，我们经常会接触到这样一种数据类型，它们的成员是<em>有序排列</em>的，并且能够通过下标偏移量可以访问它的具体的成员，这种Python类型统称为<strong>序列</strong>，序列主要包括<em>字符串、列表和元组</em>。</p>
<h1 id="u5E8F_u5217"><a href="#u5E8F_u5217" class="headerlink" title="序列"></a>序列</h1><p>序列：一种有序排列的、可以通过下标偏移量进行访问的数据类型。下标偏移量是从0开始到总元素数-1，这种访问形式和我们C语言中的数组的访问形式相同。</p>
<h2 id="u5E8F_u5217_u7C7B_u578B_u64CD_u4F5C_u7B26"><a href="#u5E8F_u5217_u7C7B_u578B_u64CD_u4F5C_u7B26" class="headerlink" title="序列类型操作符"></a>序列类型操作符</h2><p>序列类型操作符主要分为成员关系操作符（in 、not in）、连接操作符（+）、重复操作符（*）、切片操作符（[]、[:]、[::]）</p>
<h3 id="u6210_u5458_u5173_u7CFB_u64CD_u4F5C_u7B26_uFF08in_u3001not_in_uFF09"><a href="#u6210_u5458_u5173_u7CFB_u64CD_u4F5C_u7B26_uFF08in_u3001not_in_uFF09" class="headerlink" title="成员关系操作符（in、not in）"></a>成员关系操作符（in、not in）</h3><p>成员关系操作符主要是用来判断一个元素是否属于一个序列的。in/not in操作符的返回值一般来讲是一个布尔值False/True。满足成员关系就返回True，否则返回False。</p>
<p>对象 [not] in 序列</p>
<pre><code>seq = &quot;Hello&quot; # 字符串
&apos;H&apos; in seq  True

number = (1,2,3,4,5) # 元组
2 not in number  False 
</code></pre><h3 id="u8FDE_u63A5_u64CD_u4F5C_u7B26_uFF08+_uFF09"><a href="#u8FDE_u63A5_u64CD_u4F5C_u7B26_uFF08+_uFF09" class="headerlink" title="连接操作符（+）"></a>连接操作符（+）</h3><p>通过这个操作符，我们可以简单地把两个相同类型的序列连接成一个新的序列。</p>
<p>sequeue = sequeue1 + sequeue2</p>
<p>注意：这种操作虽然简单，但是比较占用内存，尽量少使用。</p>
<pre><code>sequeue1 = &quot;Hello&quot;
sequeue2 = &quot; Word!&quot;
sequeue = sequeue1 + sequeue2
print sequeue
</code></pre><h3 id="u91CD_u590D_u64CD_u4F5C_u7B26_uFF08*_uFF09"><a href="#u91CD_u590D_u64CD_u4F5C_u7B26_uFF08*_uFF09" class="headerlink" title="重复操作符（*）"></a>重复操作符（*）</h3><p>如果我们需要一个序列的多份拷贝时，这种操作符比较有用。</p>
<p>sequeue * copy_num</p>
<pre><code># 使用它来做分割线
sequeue = _
sequeue = sequeue * 6
print sequeue 
</code></pre><h3 id="u64CD_u4F5C_u7B26_uFF08_5B_5D_u3001_5B_3A_5D_u3001_5B_3A_3A_5D_uFF09"><a href="#u64CD_u4F5C_u7B26_uFF08_5B_5D_u3001_5B_3A_5D_u3001_5B_3A_3A_5D_uFF09" class="headerlink" title="操作符（[]、[:]、[::]）"></a>操作符（[]、[:]、[::]）</h3><p>序列类型就是包含一些顺序排列的对象的一个结构。我们可以使用[]加下标偏移量来访问一个元素或者[start_index:end_index]访问连续的几个元素或使用[start_index:end_index:num]来间隔num个元素访问序列。</p>
<h4 id="u64CD_u4F5C_u7B26_5B_5D"><a href="#u64CD_u4F5C_u7B26_5B_5D" class="headerlink" title="操作符[]"></a>操作符[]</h4><p>使用这种操作符只能访问一个元素。</p>
<p>sequeue[index]</p>
<p>注意：index是想要访问元素的下标偏移量，偏移量既可以为正，也可以为负。它们的区别在于正索引以序列的开始为起点，负索引是以序列的结束为起点。在使用过程尽量避免访问一个越界的索引，它会引发异常。 </p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
print names[0] 

print names[6] # 这是一个越界的索引
Traceback (most recent call last):
   File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;
     print names[6]
IndexError: list index out of range
</code></pre><h4 id="u5207_u7247_u64CD_u4F5C_u7B26_5B_3A_5D"><a href="#u5207_u7247_u64CD_u4F5C_u7B26_5B_3A_5D" class="headerlink" title="切片操作符[:]"></a>切片操作符[:]</h4><p>当我们需要同时获取多个元素时，操作符[]就有点力不从心了，虽然它可以实现，但是代码太丑陋了，所以我们就得寻找新的操作符[:]来解决问题。</p>
<p>sequeue[start_index:end_index]</p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
print names[2:4]
# result
[&apos;Faye&apos;,&apos;Ammy&apos;]
</code></pre><p>如果我们没有提供任何的起始索引和结束索引，它就会访问整个序列。</p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
# 这种方法和names[0:6]是一样的结果
print names[:]  
# result
[&apos;Dava&apos;, &apos;Joe&apos;, &apos;Faye&apos;, &apos;Ammy&apos;, &apos;Frakle&apos;, &apos;Talor&apos;]
</code></pre><p>如果我们只是提过起始索引或者结束索引，如果我们只提供起始索引，它会返回从起始索引到index-1的所有元素，如果我们只提供结束索引，它会返回从索引为0到结束索引的元素。</p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
# 我们只给了起始索引
print names[2:]
# result
[&apos;Faye&apos;, &apos;Ammy&apos;, &apos;Frakle&apos;, &apos;Talor&apos;]
# 我们只给了结束索引
print names[:3]
# result
[&apos;Dava&apos;, &apos;Joe&apos;, &apos;Faye&apos;]
</code></pre><h4 id="u5207_u7247_u64CD_u4F5C_u7B26_5B_3A_3A_5D"><a href="#u5207_u7247_u64CD_u4F5C_u7B26_5B_3A_3A_5D" class="headerlink" title="切片操作符[::]"></a>切片操作符[::]</h4><p>操作符[::]比操作符[:]多出来的第三个索引值是用做步长参数的，它和range()里面的步长参数功能相似。</p>
<p>[start_index:end_index:num]</p>
<pre><code>names = [&apos;Dava&apos;,&apos;Joe&apos;,&apos;Faye&apos;,&apos;Ammy&apos;,&apos;Frakle&apos;,&apos;Talor&apos;]
# 隔一个取一个
print names[2:6:2] 
# result
[&apos;Faye&apos;, &apos;Frakle&apos;]
</code></pre><p>注意：在序列的操作过程中，我们的打印结果是不包括结束索引所对应的那个元素的。切片索引的语法要比单一元素索引灵活得多，开始和结束索引值可以超过字符串的长度。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在Python数据类型中，我们经常会接触到这样一种数据类型，它们的成员是<em>有序排列</em>的，并且能够通过下标偏移量可以访问它的具体的成员，这种Python类型统称为<strong>序列</strong>，序列主要包括<em>字符串、列表和元组</em>。</p>]]>
    </summary>
    
      <category term="序列" scheme="http://dsljlbaby.github.io/tags/%E5%BA%8F%E5%88%97/"/>
    
      <category term="Python学习笔记" scheme="http://dsljlbaby.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(四)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/16/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%9B/"/>
    <id>http://dsljlbaby.github.io/2016/01/16/Python数据结构-四/</id>
    <published>2016-01-16T02:10:58.000Z</published>
    <updated>2016-01-16T02:31:43.618Z</updated>
    <content type="html"><![CDATA[<h2 id="u56FE"><a href="#u56FE" class="headerlink" title="图"></a>图</h2><p>图是由边或者弧连接起来的节点的网络。在有向图中，节点之间的连接是有方向的，叫做弧(arcs)。在无向图中，节点间的连接没有方向，叫做边(edge)。图算法包括查找两点间路径、两点间的最短路径、判断一个图中是否存在环(环是从一个节点可以沿一条非空路径回到它自己)、找到可以遍历所有节点的路径(著名的TSP问题，即旅行商问题)等等</p>
<h2 id="u56FE_u7684_u5B9E_u73B0"><a href="#u56FE_u7684_u5B9E_u73B0" class="headerlink" title="图的实现"></a>图的实现</h2><p>在Python中，图主要是通过列表和词典来构造。比如说下面这张图，</p>
<pre><code>A --&gt; B
A --&gt; C
B --&gt; C
B --&gt; D
C --&gt; D
D --&gt; C
E --&gt; F
F --&gt; C
</code></pre><p>就是通过下面这个字典和列表的结合进行构造</p>
<pre><code>graph = {&apos;A&apos;: [&apos;B&apos;, &apos;C&apos;],
         &apos;B&apos;: [&apos;C&apos;, &apos;D&apos;],
         &apos;C&apos;: [&apos;D&apos;],
         &apos;D&apos;: [&apos;C&apos;],
         &apos;E&apos;: [&apos;F&apos;],
         &apos;F&apos;: [&apos;C&apos;]}
</code></pre><h2 id="u6E90_u4EE3_u7801"><a href="#u6E90_u4EE3_u7801" class="headerlink" title="源代码"></a>源代码</h2><pre><code># -*- encoding:utf-8 -*-
&apos;&apos;&apos;

 A --&gt; B
 A --&gt; C
 B --&gt; C
 B --&gt; D
 C --&gt; D
 D --&gt; C
 E --&gt; F
 F --&gt; C

&apos;&apos;&apos;


def find_path(graph, start, end, path=[]):
        &apos;寻找一条路径&apos;
        path = path + [start]
        if start == end:
            return path
        if not graph.has_key(start):
            return None
        for node in graph[start]:
            if node not in path:
                newpath = find_path(graph, node, end, path)
                if newpath:
                    return newpath
        return path

def find_all_paths(graph, start, end, path=[]):
        &apos;查找所有的路径&apos;
        path = path + [start]
        if start == end:
            return [path]
        if not graph.has_key(start):
            return []
        paths = []
        for node in graph[start]:
            if node not in path:
                newpaths = find_all_paths(graph, node, end, path)
                for newpath in newpaths:
                    paths.append(newpath)
        return paths

def find_shortest_path(graph, start, end, path=[]):
        &apos;查找最短路径&apos;
        path = path + [start]
        if start == end:
            return path
        if not graph.has_key(start):
            return None
        shortest = None
        for node in graph[start]:
            if node not in path:
                newpath = find_shortest_path(graph, node, end, path)
                if newpath:
                    if not shortest or len(newpath) &lt; len(shortest):
                        shortest = newpath
        return shortest

#test

if __name__ == &apos;__main__&apos;:
    graph = {&apos;A&apos;: [&apos;B&apos;, &apos;C&apos;],
             &apos;B&apos;: [&apos;C&apos;, &apos;D&apos;],
             &apos;C&apos;: [&apos;D&apos;],
             &apos;D&apos;: [&apos;C&apos;],
             &apos;E&apos;: [&apos;F&apos;],
             &apos;F&apos;: [&apos;C&apos;]}
    print find_path(graph,&apos;A&apos;,&apos;D&apos;)
    print find_all_paths(graph,&apos;A&apos;,&apos;D&apos;)
    print find_shortest_path(graph,&apos;A&apos;,&apos;D&apos;)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u56FE"><a href="#u56FE" class="headerlink" title="图"></a>图</h2><p>图是由边或者弧连接起来的节点的网络。在有向图中，节点之间的连接是有方向的，叫做弧(arcs)。在无向图中，节点间的连接没有方向，叫做]]>
    </summary>
    
      <category term="图" scheme="http://dsljlbaby.github.io/tags/%E5%9B%BE/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(三)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/15/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%89/"/>
    <id>http://dsljlbaby.github.io/2016/01/15/Python数据结构-三/</id>
    <published>2016-01-15T02:18:04.000Z</published>
    <updated>2016-01-15T02:50:17.445Z</updated>
    <content type="html"><![CDATA[<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>bitmap是很常用的数据结构，比如用于Bloom Filter中；用于无重复整数的排序等等。bitmap通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。</p>
<h3 id="Bitmap_u7684_u5B9A_u4E49"><a href="#Bitmap_u7684_u5B9A_u4E49" class="headerlink" title="Bitmap的定义"></a>Bitmap的定义</h3><p>bitmap是很常用的数据结构，比如用于Bloom Filter中；用于无重复整数的排序等等。bitmap通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。简单的来说，这种数据结构存储把原来的数转化成二进制储存，每一位占一个储存单元，我们操作bimap中的数据，就相当于操作一个位。对于Python来说，整数类型默认是有符号类型，所以一个整数的可用位数为31位。</p>
<h3 id="Bitmap_u7684_u64CD_u4F5C"><a href="#Bitmap_u7684_u64CD_u4F5C" class="headerlink" title="Bitmap的操作"></a>Bitmap的操作</h3><p>如果我们想操作某一位数，要先获取到操作数组的第几个元素，再获取相应的位索引，然后执行操作。操作的过程大致分为初始化bitmap、计算在数组中的索引、计算在数组中的位索引、相关位置1、测试相关位。</p>
<h4 id="u521D_u59CB_u5316bitmap"><a href="#u521D_u59CB_u5316bitmap" class="headerlink" title="初始化bitmap"></a>初始化bitmap</h4><p>初始化bitmap也就是计算所需数组的大小，通常采用对最大数向上取整的方法，如果可以找到储存最大数的数组，那么其他数就不成问题了。</p>
<pre><code>class Bitmap():
    def __init__(self,max):
    self.size = int ((max + 31 - 1) / 31) #max需要传入的为要排序的最大数
</code></pre><h4 id="u8BA1_u7B97_u5728_u6570_u7EC4_u4E2D_u7684_u7D22_u5F15"><a href="#u8BA1_u7B97_u5728_u6570_u7EC4_u4E2D_u7684_u7D22_u5F15" class="headerlink" title="计算在数组中的索引"></a>计算在数组中的索引</h4><p>计算在数组中的索引与初始化btimap不同的是采用向下取整的方法，其他相同。</p>
<h4 id="u8BA1_u7B97_u5728_u6570_u7EC4_u4E2D_u7684_u4F4D_u7D22_u5F15"><a href="#u8BA1_u7B97_u5728_u6570_u7EC4_u4E2D_u7684_u4F4D_u7D22_u5F15" class="headerlink" title="计算在数组中的位索引"></a>计算在数组中的位索引</h4><p>数组元素中的位索引可以通过取模运算来得到。令需存储的整数跟31取模即可得到位索引</p>
<pre><code>def bitindex(self,num):
    return num % 31
</code></pre><h4 id="u76F8_u5173_u4F4D_u7F6E1"><a href="#u76F8_u5173_u4F4D_u7F6E1" class="headerlink" title="相关位置1"></a>相关位置1</h4><p>二进制位默认是0，将某位置1则表示在此位存储了数据</p>
<pre><code>def set_1(self,num):
    elemindex = num / 31
    byteindex = self.bitindex(num)
    ele = self.array[elemindex]
    self.array[elemindex] = ele | (1 &lt;&lt; byteindex)
</code></pre><h4 id="u6D4B_u8BD5_u76F8_u5173_u4F4D"><a href="#u6D4B_u8BD5_u76F8_u5173_u4F4D" class="headerlink" title="测试相关位"></a>测试相关位</h4><p>判断某位是否为1是为了取出之前所存储的数据</p>
<pre><code>def test_1(self,i):
    elemindex = i / 31
    byteindex = self.bitindex(i)
    if self.array[elemindex] &amp; (1 &lt;&lt; byteindex):
        return True
    return False
</code></pre><h3 id="u6E90_u4EE3_u7801"><a href="#u6E90_u4EE3_u7801" class="headerlink" title="源代码"></a>源代码</h3><pre><code># -*- encoding:utf-8 -*-
class Bitmap():
    def __init__(self,max):
        &apos;确定所需数组个数&apos;
        self.size = int ((max + 31 - 1) / 31)
        self.array = [0 for i in range(self.size)]

    def bitindex(self,num):
        &apos;确定数组中元素的位索引&apos;
        return num % 31

    def set_1(self,num):
        &apos;将元素所在的位置1&apos;
        elemindex = num / 31
        byteindex = self.bitindex(num)
        ele = self.array[elemindex]
        self.array[elemindex] = ele | (1 &lt;&lt; byteindex)

    def test_1(self,i):
        &apos;检测元素存在的位置&apos;
        elemindex = i / 31
        byteindex = self.bitindex(i)
        if self.array[elemindex] &amp; (1 &lt;&lt; byteindex):
            return True
        return False
if __name__ == &apos;__main__&apos;:
    Max = ord(&apos;z&apos;)
    suffle_array = [x for x in &apos;qwelmfg&apos;]
    result = []
    bitmap = Bitmap(Max)
    for c in suffle_array:
        bitmap.set_1(ord(c))
    for i in range(Max+1):
        if bitmap.test_1(i):
            result.append(chr(i))
    print u&apos;原始数组为:    %s&apos; % suffle_array
    print u&apos;排序后的数组为: %s&apos; % result
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>bitmap是很常用的数据结构，比如用于Bloom Filter中；用于无重复整数的排序等等。bitmap通]]>
    </summary>
    
      <category term="bitmap" scheme="http://dsljlbaby.github.io/tags/bitmap/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(二)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/14/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C/"/>
    <id>http://dsljlbaby.github.io/2016/01/14/Python数据结构-二/</id>
    <published>2016-01-14T02:28:32.000Z</published>
    <updated>2016-01-14T02:41:19.062Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E8C_u53C9_u6811_u7684_u5B9E_u73B0"><a href="#u4E8C_u53C9_u6811_u7684_u5B9E_u73B0" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><h3 id="u6811_u7684_u5B9A_u4E49"><a href="#u6811_u7684_u5B9A_u4E49" class="headerlink" title="树的定义"></a>树的定义　　</h3><p>　　树是一种重要的非线性数据结构，直观地看，它是数据元素（在树中称为结点）按分支关系组织起来的结构，很象自然界中的树那样。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树形象表示。树在计算机领域中也得到广泛应用，如在编译源程序时，可用树表示源程序的语法结构。又如在数据库系统中，树型结构也是信息的重要组织形式之一。一切具有层次关系的问题都可用树来描述。</p>
<p> 树结构的特点是：它的每一个结点都可以有不止一个直接后继，除根结点外的所有结点都有且只有一个直接前驱。</p>
<p>树的递归定义如下：</p>
<ul>
<li>至少有一个结点（称为根）</li>
<li>其它是互不相交的子树</li>
</ul>
<h3 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是由n（n≥0）个结点组成的有限集合、每个结点最多有两个子树的有序树。它或者是空集，或者是由一个根和称为左、右子树的两个不相交的二叉树组成。</p>
<p>特点：</p>
<ul>
<li>二叉树是有序树，即使只有一个子树，也必须区分左、右子树；</li>
</ul>
<ul>
<li>二叉树的每个结点的度不能大于2，只能取0、1、2三者之一；</li>
</ul>
<ul>
<li>二叉树中所有结点的形态有5种：空结点、无左右子树的结点、只有左子树的结点、只有右子树的结点和具有左右子树的结点。</li>
</ul>
<h3 id="u6E90_u4EE3_u7801_uFF1A"><a href="#u6E90_u4EE3_u7801_uFF1A" class="headerlink" title="源代码："></a>源代码：</h3><pre><code>#-*- encoding:utf-8 -*-

&apos;&apos;&apos;
树的构建：
     5
  6     7
8         9
&apos;&apos;&apos;

class Tree():
   &apos;树的实现&apos;
    def __init__(self,ltree = 0,rtree = 0,data = 0):
        self.ltree = ltree
        self.rtree = rtree
        self.data = data
class BTree():
    &apos;二叉树的实现&apos;
    def __init__(self,base = 0):
        self.base = base
    def _Empty(self):
        &apos;是否为空树&apos;
        if self.base == 0:
            return True
        else:
            return False
    def qout(self,tree_base):
        &apos;前序遍历:根-左-右&apos;
        if tree_base == 0:
            return
        print tree_base.data
        self.qout(tree_base.ltree)
        self.qout(tree_base.rtree)
    def mout(self,tree_base):
        &apos;中序遍历:左-根-右&apos;
        if tree_base == 0:
            return
        self.mout(tree_base.ltree)
        print tree_base.data
        self.mout(tree_base.rtree)
    def hout(self,tree_base):
        &apos;后序遍历:左-右-根&apos;
        if tree_base == 0:
            return
        self.hout(tree_base.ltree)
        self.hout(tree_base.rtree)
        print tree_base.data
#test

tree1 = Tree(data=8)
tree2 = Tree(data=9)
tree3 = Tree(tree1,data=6)
tree4 = Tree(tree2,0,data=7)
base = Tree(tree3,tree4,5)
btree = BTree(base)
print &apos;前序遍历结果:&apos;
btree.qout(btree.base)
print &apos;中序遍历结果:&apos;
btree.mout(btree.base)
print &apos;后序遍历结果:&apos;
btree.hout(btree.base)
</code></pre><h2 id="u94FE_u8868_u7684_u5B9E_u73B0"><a href="#u94FE_u8868_u7684_u5B9E_u73B0" class="headerlink" title="链表的实现"></a>链表的实现</h2><h3 id="u94FE_u8868_u7684_u5B9A_u4E49"><a href="#u94FE_u8868_u7684_u5B9A_u4E49" class="headerlink" title="链表的定义"></a>链表的定义</h3><p>　　链表(linked list)是由一组被称为结点的数据元素组成的数据结构，每个结点都包含结点本身的信息和指向下一个结点的地址。由于每个结点都包含了可以链接起来的地址信息，所以用一个变量就能够访问整个结点序列。也就是说，结点包含两部分信息：一部分用于存储数据元素的值，称为信息域；另一部分用于存储下一个数据元素地址的指针，称为指针域。链表中的第一个结点的地址存储在一个单独的结点中，称为头结点或首结点。链表中的最后一个结点没有后继元素，其指针域为空。</p>
<h3 id="u6E90_u4EE3_u7801"><a href="#u6E90_u4EE3_u7801" class="headerlink" title="源代码"></a>源代码</h3><pre><code># -*- encoding:utf-8 -*-
class Node():
    &apos;创建节点&apos;
    def __init__(self,data):
        self.data = data
        self.next = None

class LinkList():
    &apos;创建列表&apos;
    def __init__(self, node):
        &apos;初始化列表&apos;
        self.head = node
        self.head.next = None
        self.tail = self.head

    def add_node(self, node):
        &apos;添加节点&apos;
        self.tail.next = node
        self.tail = self.tail.next

    def view(self):
        &apos;查看列表&apos;
        node = self.head
        link_str = &apos;&apos;
        while node is not None:
            if node.next is not None:
                link_str += str(node.data) + &apos;--&gt;&apos;
            else:
                link_str += str(node.data)
            node = node.next
        print &apos;The Linklist is:&apos; + link_str

    def length(self):
        &apos;列表长度&apos;
        node = self.head
        count = 1
        while node.next is not None:
            count += 1
            node = node.next
        print &apos;The length of linklist are %d&apos; % count
        return count

    def delete_node(self, index):
        &apos;删除节点&apos;
        if index+1 &gt; self.length():
            raise IndexError(&apos;index out of bounds&apos;)
        num = 0
        node = self.head
        while True:
            if num == index-1:
                break
            node = node.next
            num += 1
        tmp_node = node.next
        node.next = node.next.next
        return tmp_node.data

    def find_node(self, index):
        &apos;查看具体节点&apos;
        if index+1 &gt; self.length():
            raise IndexError(&apos;index out of bounds&apos;)
        num = 0
        node = self.head
        while True:
            if num == index:
                break
            node = node.next
            num += 1
        return node.data

# test

node1 = Node(10)
node2 = Node(&apos;dec&apos;)
node3 = Node(1010)
node4 = Node(&apos;bin&apos;)
node5 = Node(12)
node6 = Node(&apos;oct&apos;)
node7 = Node(&apos;A&apos;)
node8 = Node(&apos;hex&apos;)

linklist = LinkList(node1)
linklist.add_node(node2)
linklist.add_node(node3)
linklist.add_node(node4)
linklist.add_node(node5)
linklist.add_node(node6)
linklist.add_node(node7)
linklist.add_node(node8)

linklist.view()
linklist.length()
linklist.delete_node(1)
linklist.view()
find_node = linklist.find_node(6)
print find_node
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E8C_u53C9_u6811_u7684_u5B9E_u73B0"><a href="#u4E8C_u53C9_u6811_u7684_u5B9E_u73B0" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2]]>
    </summary>
    
      <category term="二叉树" scheme="http://dsljlbaby.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="链表" scheme="http://dsljlbaby.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(一)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/13/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80/"/>
    <id>http://dsljlbaby.github.io/2016/01/13/Python数据结构-一/</id>
    <published>2016-01-13T03:03:18.000Z</published>
    <updated>2016-01-14T02:41:19.063Z</updated>
    <content type="html"><![CDATA[<h3 id="u5806_u6808_u7684_u5B9E_u73B0"><a href="#u5806_u6808_u7684_u5B9E_u73B0" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h3><p>堆栈的实现方式主要为“先进后出”，类似于我们清洗饭后的碗碟。</p>
<h4 id="u6E90_u4EE3_u7801_uFF1A"><a href="#u6E90_u4EE3_u7801_uFF1A" class="headerlink" title="源代码："></a>源代码：</h4><pre><code>class Stack():
    def __init__(self,size):
        self.list = []
        self.size = size
        self.top = -1
    def _Full(self):
        if self.top == self.size - 1:
            return True
        else:
            return False
    def _Empty(self):
        if self.top == -1:
            return True
        else:
            return False
    def instack(self,_list):
        if self._Full():
            print &apos;The stack is Full.&apos;
        else:
            self.list.append(_list)
            self.top = self.top + 1
    def outstack(self):
        if self._Empty():
            print &apos;The stack is empty.!&apos;
        else:
            self.list.pop()
            self.top = self.top - 1
# test

s = Stack(10)
print s._Full()
print s._Empty()
for i in range(10):
    s.instack(i)
print s._Full()
for i in range(10):
    s.outstack()
print s._Empty()
</code></pre><h3 id="u961F_u5217_u7684_u5B9E_u73B0"><a href="#u961F_u5217_u7684_u5B9E_u73B0" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>队列的实现方式主要为“先进先出”，类似于我们生活中排队。</p>
<h4 id="u6E90_u4EE3_u7801_uFF1A-1"><a href="#u6E90_u4EE3_u7801_uFF1A-1" class="headerlink" title="源代码："></a>源代码：</h4><pre><code>class Queue():
    def __init__(self,size):
        self.list = []
        self.size = size
        self.front = -1
        self.rear = -1
    def _Empty(self):
        if self.front == self.rear:
            return True
        else:
            return False
    def _Full(self):
        if self.rear - self.front + 1 == self.size:
            return True
        else:
            return False
    def inqueue(self,_list):
        if self._Full():
            print &apos;The Queue is full.&apos;
        else:
            self.list.append(_list)
            self.rear = self.rear + 1
    def outqueue(self):
        if self._Empty():
            print &apos;The Queue is empty.&apos;
        else:
            self.list.pop()
            self.front = self.front + 1
#test

q = Queue(10)
print q._Empty()
print q._Full()
for i in range(10):
    q.inqueue(i)
print q._Full()
for i in range(10):
    q.outqueue()
print q._Empty()
</code></pre><p>堆栈和队列的容器均之所以选择列表list，而不选择元组tuple,主要是因为列表具有可以进行动态修改，元组不允许修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5806_u6808_u7684_u5B9E_u73B0"><a href="#u5806_u6808_u7684_u5B9E_u73B0" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h3><p>堆栈的实现方式主要为]]>
    </summary>
    
      <category term="堆栈" scheme="http://dsljlbaby.github.io/tags/%E5%A0%86%E6%A0%88/"/>
    
      <category term="队列" scheme="http://dsljlbaby.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不一样的2016]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/02/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%842016/"/>
    <id>http://dsljlbaby.github.io/2016/01/02/不一样的2016/</id>
    <published>2016-01-02T02:57:50.000Z</published>
    <updated>2016-01-02T07:19:00.993Z</updated>
    <content type="html"><![CDATA[<p>2015已经悄然逝去，早已忘却2015年的计划，每一年的开始，我都会满怀信心的写下自己的计划，等到年末的时候，拿出来才发现并没有几个计划如愿以偿地完成，然后，又继续重新欺骗自己，这样的岁月一载又一载，想想就会令人发笑。2016是否会继续下去？我的内心发出“不，我要不一样的2016！”</p>
<p>唯一值得肯定的就是在2015年，我会保证每月至少读一本书，这样的习惯还算不错的。有人说过，我们生活中碰到的各种各样的问题都会在书中得以找到答案，只要你肯。我想这也是我坚持读书的原因吧。在知乎或者Quora上存在这样一类问题“在20岁的时候，你应该懂得什么?”,”20岁做什么，可以在5年后受益匪浅”，“20岁的时候，学习XX晚不晚？”，我经常想，为什么这类问题会这么多？我想大概是因为在20岁的时候，我们最迷茫，我们不知道接下来的路如何去走下去，而迷茫与困惑的核心原因难道不是对外部环境缺乏规律性的认识？有人说“人生最重要的两天：你出生的那天和你想明白自己为什么出生在这个世界的那天”，我想我们不要急于追寻未知的自己，做好当下的自己，对于那些一直在询问“XX时候学习XX晚不晚”的想法，我想说的是“15岁觉得游泳难，放弃游泳，到18岁遇到一个你喜欢的人约你去游泳，你只好说“我不会耶”。18岁觉得英文难，放弃英文，28岁出现一个很棒但要会英文的工作，你只好说“我不会耶”。人生前期越嫌麻烦，越懒得学，后来就越可能错过让你动心的人和事，错过新风景。”</p>
<p>2016年，我大三，意味着接下来摆在我面前的将会有两条路，要么考研？要么工作？每一种选择后面都有不一样的人生。人最可悲的事情莫过于欺骗自己，当看见别人的辉煌时，我们总是想象着要是我拥有XX的环境，我也会和他一样，甚至比他优秀。可是，当我们真的拥有一样的环境时，我们会做的更好吗？可能是，也可能不是。我觉得一个人是否成功最重要是是认清自己，认清所处的环境，我们需要去适应环境。每一次，打电话给父母，父母都会劝我读研，我一直含含糊糊地回答这个问题，我知道我一直在逃避，我也不知道我接下来的路该如何走？正如我当初并没有做好上大学的准备，也就这样浑浑噩噩地度过了三年，当考研摆在我面前时，我不想再像三年前不知道如何面对大学的自己一样，我不想把我的青春浪费在无知上，我要为我做出的每一个选择负责，同时，我也要明白自己为什么这样选择。我感觉采铜老师的这份答案蛮不错的，建议每一个迷茫的大学生看看。<a href="https://www.zhihu.com/question/20079854/answer/15158846" title="大学和职场的脱节" target="_blank" rel="external">https://www.zhihu.com/question/20079854/answer/15158846</a></p>
<p>最后，我希望自己在2016年只要做好两件事就可以了，即读书与反思。<br><img src="http://i.imgur.com/LtOVsT0.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015已经悄然逝去，早已忘却2015年的计划，每一年的开始，我都会满怀信心的写下自己的计划，等到年末的时候，拿出来才发现并没有几个计划如愿以偿地完成，然后，又继续重新欺骗自己，这样的岁月一载又一载，想想就会令人发笑。2016是否会继续下去？我的内心发出“不，我要不一样的2]]>
    </summary>
    
      <category term="生活" scheme="http://dsljlbaby.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://dsljlbaby.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫基础（一）]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/02/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://dsljlbaby.github.io/2016/01/02/Python爬虫基础（一）/</id>
    <published>2016-01-02T01:53:50.000Z</published>
    <updated>2016-01-02T07:29:34.123Z</updated>
    <content type="html"><![CDATA[<p>大家好，最近博主在学习Python，每天只是Print，感觉好枯燥，所以打算利用学习网络爬虫来加深自己的Python功底，在此将自己的学习系统地整理下来，如果大家有兴趣学习爬虫的话，可以将这些文章作为参考，也欢迎大家一共分享学习经验。</p>
<h2 id="u7F51_u7EDC_u722C_u866B_u7684_u57FA_u672C_u4ECB_u7ECD"><a href="#u7F51_u7EDC_u722C_u866B_u7684_u57FA_u672C_u4ECB_u7ECD" class="headerlink" title="网络爬虫的基本介绍"></a>网络爬虫的基本介绍</h2><p>学习爬虫，我想主要从以下几个方面来切入</p>
<ul>
<li>爬虫的原理？</li>
<li>爬虫的作用？</li>
<li>爬虫的实现？</li>
<li>爬虫的工具？</li>
</ul>
<h2 id="u722C_u866B_u7684_u539F_u7406"><a href="#u722C_u866B_u7684_u539F_u7406" class="headerlink" title="爬虫的原理"></a>爬虫的原理</h2><p>爬虫就是一种自动获取网页内容，提取有价值的数据的技术。把互联网比喻成一个蜘蛛网，把你想象成一只蜘蛛，如果要你浏览全部网页，你会如何进行？从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，然后通过这些链接地址寻找下一个网页，这样一直循环下去，直到把这个网站所有的网页都抓取完为止。网络爬虫的基本操作是抓取网页。</p>
<h2 id="u722C_u866B_u7684_u4F5C_u7528"><a href="#u722C_u866B_u7684_u4F5C_u7528" class="headerlink" title="爬虫的作用"></a>爬虫的作用</h2><p>方便获取互联网数据，为我所用。假如你是一个科幻迷，想要获取豆瓣上关于科幻电影的信息，你就可以通过写一个简单的脚本，去抓取关于科幻电影的信息。又或者朋友向你推荐一部好看的动漫，你想要下载整部动漫时，你也可以写个爬虫程序，去获取下载链接。</p>
<h2 id="u722C_u866B_u7684_u5B9E_u73B0"><a href="#u722C_u866B_u7684_u5B9E_u73B0" class="headerlink" title="爬虫的实现"></a>爬虫的实现</h2><p><img src="http://i.imgur.com/AJenPpZ.png" alt=""></p>
<p>爬虫实现的过程中主要包括了抓取网页、存储、网页分析、展示预期结果。</p>
<h2 id="u722C_u866B_u7684_u5DE5_u5177"><a href="#u722C_u866B_u7684_u5DE5_u5177" class="headerlink" title="爬虫的工具"></a>爬虫的工具</h2><p>刚开始学习爬虫，我们需要掌握以下几个库的使用。</p>
<ol>
<li>打开网页，下载文件：urllib、urllib2</li>
<li>解析网页：BeautifulSoup，熟悉JQuery的可以用Pyquery </li>
<li>使用Requests来提交各种类型的请求，支持重定向，cookies等。</li>
<li>使用Selenium，模拟浏览器提交类似用户的操作，处理js动态产生的网页</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>大家好，最近博主在学习Python，每天只是Print，感觉好枯燥，所以打算利用学习网络爬虫来加深自己的Python功底，在此将自己的学习系统地整理下来，如果大家有兴趣学习爬虫的话，可以将这些文章作为参考，也欢迎大家一共分享学习经验。</p>
<h2 id="u7F51_u]]>
    </summary>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://dsljlbaby.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫基础（二）]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/02/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://dsljlbaby.github.io/2016/01/02/Python爬虫基础（二）/</id>
    <published>2016-01-02T01:44:33.000Z</published>
    <updated>2016-01-02T01:57:09.657Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们大概地了解了网络爬虫的一些基本知识，这篇博文主要讲述下我们平时浏览网页时，浏览器如何响应我们的访问以及URL、URI的相关知识。</p>
<p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫学习有很大帮助。</p>
<h2 id="u6D4F_u89C8_u7F51_u9875_u7684_u8FC7_u7A0B"><a href="#u6D4F_u89C8_u7F51_u9875_u7684_u8FC7_u7A0B" class="headerlink" title="浏览网页的过程"></a>浏览网页的过程</h2><p>用户在浏览器中输入我们想要查询的信息后，浏览器就会作为一个客户端，经过DNS服务器，找到服务器主机，向服务器发出一个请求，服务器经过解析之后，发送给用户的浏览器 HTML、JS、CSS 等文件，浏览器解析出来，用户便可以看到我们所需要的信息啦。</p>
<p>浏览器的功能是将获取到的HTML代码进行解析，然后将原始的代码转变成我们直接看到的网站页面。</p>
<p>HTML是一种标记语言，用标签标记内容并加以解析和区分</p>
<p>因此，抓取网页的过程其实和用户平时使用浏览器浏览网页的道理是一样的。用户看到的网页实质是由 HTML 代码构成的，爬虫爬来的便是这些内容，通过分析和过滤这些 HTML 代码，实现对图片、文字等资源的获取。</p>
<h2 id="URI_u548CURL_u7684_u8BA4_u8BC6"><a href="#URI_u548CURL_u7684_u8BA4_u8BC6" class="headerlink" title="URI和URL的认识"></a>URI和URL的认识</h2><p>在爬虫的实现中，我们曾提到调度器首先要从URL管理器中获得URL，才可以进行下一步的访问。那么URL是什么呢？简单的来讲，URL就是在浏览器端输入一个要访问的网址，比如说百度首页的网址    <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>    就是一个URL。</p>
<p>在理解URL（统一资源定位符）之前，我们还是首先理解下URI（统一资源标识符）的概念。</p>
<h3 id="u4EC0_u4E48_u662FURI_uFF1F"><a href="#u4EC0_u4E48_u662FURI_uFF1F" class="headerlink" title="什么是URI？"></a>什么是URI？</h3><p>Web上每种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个通用资源标志符(Universal Resource Identifier， URI)进行定位。 </p>
<p>URI通常由三部分组成：</p>
<ol>
<li>访问资源的命名机制；</li>
<li>存放资源的主机名；</li>
<li>资源自身的名称，由路径表示。</li>
</ol>
<p>如下面的URI：</p>
<p><a href="http://mooc.guokr.com/html/html21/" target="_blank" rel="external">http://mooc.guokr.com/html/html21/</a></p>
<p>我们可以这样解释它：</p>
<ol>
<li>这是一个可以通过HTTP协议访问的资源,使用http:或者https:等协议方案名获取资源时需要制定协议类型。</li>
<li>位于主机mooc.guokr.com上。</li>
<li>通过路径”/html/html21”访问。</li>
</ol>
<h3 id="u4EC0_u4E48_u662FURL_uFF1F"><a href="#u4EC0_u4E48_u662FURL_uFF1F" class="headerlink" title="什么是URL？"></a>什么是URL？</h3><p>URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位符”。也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。</p>
<p>URL的一般格式为(带方括号[]的为可选项)：<br>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</p>
<p>同样地，URL的格式也主要由三部分组成： </p>
<ol>
<li>第一部分是协议(或称为服务方式)。</li>
<li>第二部分是存有该资源的主机IP地址(有时也包括端口号)。</li>
<li>第三部分是主机资源的具体地址，如目录和文件名等。<br>第一部分和第二部分用“://”符号隔开，</li>
</ol>
<p>第二部分和第三部分用“/”符号隔开。</p>
<p>第一部分和第二部分是不可缺少的，第三部分有时可以省略。</p>
<p>如下面的URL：</p>
<p><a href="https://www.coursera.org/course/interactivepython1" target="_blank" rel="external">https://www.coursera.org/course/interactivepython1</a></p>
<ol>
<li>这是一个可以通过HTTPS协议访问的资源</li>
<li>计算机域名是www.coursera.org</li>
<li>interactivepython1存放在主机www.coursera.org上的目录/course下</li>
</ol>
<h3 id="URL_u548CURI_u7684_u533A_u522B"><a href="#URL_u548CURI_u7684_u533A_u522B" class="headerlink" title="URL和URI的区别"></a>URL和URI的区别</h3><p>URL是URI的一个子集，URI表示请求服务器的路径，定义这么一个资源，而URL同时说明要如何访问这个资源（http://）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们大概地了解了网络爬虫的一些基本知识，这篇博文主要讲述下我们平时浏览网页时，浏览器如何响应我们的访问以及URL、URI的相关知识。</p>
<p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫]]>
    </summary>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://dsljlbaby.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
