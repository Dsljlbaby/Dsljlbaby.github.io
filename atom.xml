<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Dsljlbaby's Blog]]></title>
  <subtitle><![CDATA[只有行动才能说明一切]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dsljlbaby.github.io/"/>
  <updated>2016-01-14T02:41:19.062Z</updated>
  <id>http://dsljlbaby.github.io/</id>
  
  <author>
    <name><![CDATA[Dsljlbaby]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python数据结构(二)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/14/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C/"/>
    <id>http://dsljlbaby.github.io/2016/01/14/Python数据结构-二/</id>
    <published>2016-01-14T02:28:32.000Z</published>
    <updated>2016-01-14T02:41:19.062Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E8C_u53C9_u6811_u7684_u5B9E_u73B0"><a href="#u4E8C_u53C9_u6811_u7684_u5B9E_u73B0" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><h3 id="u6811_u7684_u5B9A_u4E49"><a href="#u6811_u7684_u5B9A_u4E49" class="headerlink" title="树的定义"></a>树的定义　　</h3><p>　　树是一种重要的非线性数据结构，直观地看，它是数据元素（在树中称为结点）按分支关系组织起来的结构，很象自然界中的树那样。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树形象表示。树在计算机领域中也得到广泛应用，如在编译源程序时，可用树表示源程序的语法结构。又如在数据库系统中，树型结构也是信息的重要组织形式之一。一切具有层次关系的问题都可用树来描述。</p>
<p> 树结构的特点是：它的每一个结点都可以有不止一个直接后继，除根结点外的所有结点都有且只有一个直接前驱。</p>
<p>树的递归定义如下：</p>
<ul>
<li>至少有一个结点（称为根）</li>
<li>其它是互不相交的子树</li>
</ul>
<h3 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是由n（n≥0）个结点组成的有限集合、每个结点最多有两个子树的有序树。它或者是空集，或者是由一个根和称为左、右子树的两个不相交的二叉树组成。</p>
<p>特点：</p>
<ul>
<li>二叉树是有序树，即使只有一个子树，也必须区分左、右子树；</li>
</ul>
<ul>
<li>二叉树的每个结点的度不能大于2，只能取0、1、2三者之一；</li>
</ul>
<ul>
<li>二叉树中所有结点的形态有5种：空结点、无左右子树的结点、只有左子树的结点、只有右子树的结点和具有左右子树的结点。</li>
</ul>
<h3 id="u6E90_u4EE3_u7801_uFF1A"><a href="#u6E90_u4EE3_u7801_uFF1A" class="headerlink" title="源代码："></a>源代码：</h3><pre><code>#-*- encoding:utf-8 -*-

&apos;&apos;&apos;
树的构建：
     5
  6     7
8         9
&apos;&apos;&apos;

class Tree():
   &apos;树的实现&apos;
    def __init__(self,ltree = 0,rtree = 0,data = 0):
        self.ltree = ltree
        self.rtree = rtree
        self.data = data
class BTree():
    &apos;二叉树的实现&apos;
    def __init__(self,base = 0):
        self.base = base
    def _Empty(self):
        &apos;是否为空树&apos;
        if self.base == 0:
            return True
        else:
            return False
    def qout(self,tree_base):
        &apos;前序遍历:根-左-右&apos;
        if tree_base == 0:
            return
        print tree_base.data
        self.qout(tree_base.ltree)
        self.qout(tree_base.rtree)
    def mout(self,tree_base):
        &apos;中序遍历:左-根-右&apos;
        if tree_base == 0:
            return
        self.mout(tree_base.ltree)
        print tree_base.data
        self.mout(tree_base.rtree)
    def hout(self,tree_base):
        &apos;后序遍历:左-右-根&apos;
        if tree_base == 0:
            return
        self.hout(tree_base.ltree)
        self.hout(tree_base.rtree)
        print tree_base.data
#test

tree1 = Tree(data=8)
tree2 = Tree(data=9)
tree3 = Tree(tree1,data=6)
tree4 = Tree(tree2,0,data=7)
base = Tree(tree3,tree4,5)
btree = BTree(base)
print &apos;前序遍历结果:&apos;
btree.qout(btree.base)
print &apos;中序遍历结果:&apos;
btree.mout(btree.base)
print &apos;后序遍历结果:&apos;
btree.hout(btree.base)
</code></pre><h2 id="u94FE_u8868_u7684_u5B9E_u73B0"><a href="#u94FE_u8868_u7684_u5B9E_u73B0" class="headerlink" title="链表的实现"></a>链表的实现</h2><h3 id="u94FE_u8868_u7684_u5B9A_u4E49"><a href="#u94FE_u8868_u7684_u5B9A_u4E49" class="headerlink" title="链表的定义"></a>链表的定义</h3><p>　　链表(linked list)是由一组被称为结点的数据元素组成的数据结构，每个结点都包含结点本身的信息和指向下一个结点的地址。由于每个结点都包含了可以链接起来的地址信息，所以用一个变量就能够访问整个结点序列。也就是说，结点包含两部分信息：一部分用于存储数据元素的值，称为信息域；另一部分用于存储下一个数据元素地址的指针，称为指针域。链表中的第一个结点的地址存储在一个单独的结点中，称为头结点或首结点。链表中的最后一个结点没有后继元素，其指针域为空。</p>
<h3 id="u6E90_u4EE3_u7801"><a href="#u6E90_u4EE3_u7801" class="headerlink" title="源代码"></a>源代码</h3><pre><code># -*- encoding:utf-8 -*-
class Node():
    &apos;创建节点&apos;
    def __init__(self,data):
        self.data = data
        self.next = None

class LinkList():
    &apos;创建列表&apos;
    def __init__(self, node):
        &apos;初始化列表&apos;
        self.head = node
        self.head.next = None
        self.tail = self.head

    def add_node(self, node):
        &apos;添加节点&apos;
        self.tail.next = node
        self.tail = self.tail.next

    def view(self):
        &apos;查看列表&apos;
        node = self.head
        link_str = &apos;&apos;
        while node is not None:
            if node.next is not None:
                link_str += str(node.data) + &apos;--&gt;&apos;
            else:
                link_str += str(node.data)
            node = node.next
        print &apos;The Linklist is:&apos; + link_str

    def length(self):
        &apos;列表长度&apos;
        node = self.head
        count = 1
        while node.next is not None:
            count += 1
            node = node.next
        print &apos;The length of linklist are %d&apos; % count
        return count

    def delete_node(self, index):
        &apos;删除节点&apos;
        if index+1 &gt; self.length():
            raise IndexError(&apos;index out of bounds&apos;)
        num = 0
        node = self.head
        while True:
            if num == index-1:
                break
            node = node.next
            num += 1
        tmp_node = node.next
        node.next = node.next.next
        return tmp_node.data

    def find_node(self, index):
        &apos;查看具体节点&apos;
        if index+1 &gt; self.length():
            raise IndexError(&apos;index out of bounds&apos;)
        num = 0
        node = self.head
        while True:
            if num == index:
                break
            node = node.next
            num += 1
        return node.data

# test

node1 = Node(10)
node2 = Node(&apos;dec&apos;)
node3 = Node(1010)
node4 = Node(&apos;bin&apos;)
node5 = Node(12)
node6 = Node(&apos;oct&apos;)
node7 = Node(&apos;A&apos;)
node8 = Node(&apos;hex&apos;)

linklist = LinkList(node1)
linklist.add_node(node2)
linklist.add_node(node3)
linklist.add_node(node4)
linklist.add_node(node5)
linklist.add_node(node6)
linklist.add_node(node7)
linklist.add_node(node8)

linklist.view()
linklist.length()
linklist.delete_node(1)
linklist.view()
find_node = linklist.find_node(6)
print find_node
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E8C_u53C9_u6811_u7684_u5B9E_u73B0"><a href="#u4E8C_u53C9_u6811_u7684_u5B9E_u73B0" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2]]>
    </summary>
    
      <category term="二叉树" scheme="http://dsljlbaby.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="链表" scheme="http://dsljlbaby.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python数据结构(一)]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/13/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80/"/>
    <id>http://dsljlbaby.github.io/2016/01/13/Python数据结构-一/</id>
    <published>2016-01-13T03:03:18.000Z</published>
    <updated>2016-01-14T02:41:19.063Z</updated>
    <content type="html"><![CDATA[<h3 id="u5806_u6808_u7684_u5B9E_u73B0"><a href="#u5806_u6808_u7684_u5B9E_u73B0" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h3><p>堆栈的实现方式主要为“先进后出”，类似于我们清洗饭后的碗碟。</p>
<h4 id="u6E90_u4EE3_u7801_uFF1A"><a href="#u6E90_u4EE3_u7801_uFF1A" class="headerlink" title="源代码："></a>源代码：</h4><pre><code>class Stack():
    def __init__(self,size):
        self.list = []
        self.size = size
        self.top = -1
    def _Full(self):
        if self.top == self.size - 1:
            return True
        else:
            return False
    def _Empty(self):
        if self.top == -1:
            return True
        else:
            return False
    def instack(self,_list):
        if self._Full():
            print &apos;The stack is Full.&apos;
        else:
            self.list.append(_list)
            self.top = self.top + 1
    def outstack(self):
        if self._Empty():
            print &apos;The stack is empty.!&apos;
        else:
            self.list.pop()
            self.top = self.top - 1
# test

s = Stack(10)
print s._Full()
print s._Empty()
for i in range(10):
    s.instack(i)
print s._Full()
for i in range(10):
    s.outstack()
print s._Empty()
</code></pre><h3 id="u961F_u5217_u7684_u5B9E_u73B0"><a href="#u961F_u5217_u7684_u5B9E_u73B0" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>队列的实现方式主要为“先进先出”，类似于我们生活中排队。</p>
<h4 id="u6E90_u4EE3_u7801_uFF1A-1"><a href="#u6E90_u4EE3_u7801_uFF1A-1" class="headerlink" title="源代码："></a>源代码：</h4><pre><code>class Queue():
    def __init__(self,size):
        self.list = []
        self.size = size
        self.front = -1
        self.rear = -1
    def _Empty(self):
        if self.front == self.rear:
            return True
        else:
            return False
    def _Full(self):
        if self.rear - self.front + 1 == self.size:
            return True
        else:
            return False
    def inqueue(self,_list):
        if self._Full():
            print &apos;The Queue is full.&apos;
        else:
            self.list.append(_list)
            self.rear = self.rear + 1
    def outqueue(self):
        if self._Empty():
            print &apos;The Queue is empty.&apos;
        else:
            self.list.pop()
            self.front = self.front + 1
#test

q = Queue(10)
print q._Empty()
print q._Full()
for i in range(10):
    q.inqueue(i)
print q._Full()
for i in range(10):
    q.outqueue()
print q._Empty()
</code></pre><p>堆栈和队列的容器均之所以选择列表list，而不选择元组tuple,主要是因为列表具有可以进行动态修改，元组不允许修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5806_u6808_u7684_u5B9E_u73B0"><a href="#u5806_u6808_u7684_u5B9E_u73B0" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h3><p>堆栈的实现方式主要为]]>
    </summary>
    
      <category term="堆栈" scheme="http://dsljlbaby.github.io/tags/%E5%A0%86%E6%A0%88/"/>
    
      <category term="队列" scheme="http://dsljlbaby.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不一样的2016]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/02/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%842016/"/>
    <id>http://dsljlbaby.github.io/2016/01/02/不一样的2016/</id>
    <published>2016-01-02T02:57:50.000Z</published>
    <updated>2016-01-02T07:19:00.993Z</updated>
    <content type="html"><![CDATA[<p>2015已经悄然逝去，早已忘却2015年的计划，每一年的开始，我都会满怀信心的写下自己的计划，等到年末的时候，拿出来才发现并没有几个计划如愿以偿地完成，然后，又继续重新欺骗自己，这样的岁月一载又一载，想想就会令人发笑。2016是否会继续下去？我的内心发出“不，我要不一样的2016！”</p>
<p>唯一值得肯定的就是在2015年，我会保证每月至少读一本书，这样的习惯还算不错的。有人说过，我们生活中碰到的各种各样的问题都会在书中得以找到答案，只要你肯。我想这也是我坚持读书的原因吧。在知乎或者Quora上存在这样一类问题“在20岁的时候，你应该懂得什么?”,”20岁做什么，可以在5年后受益匪浅”，“20岁的时候，学习XX晚不晚？”，我经常想，为什么这类问题会这么多？我想大概是因为在20岁的时候，我们最迷茫，我们不知道接下来的路如何去走下去，而迷茫与困惑的核心原因难道不是对外部环境缺乏规律性的认识？有人说“人生最重要的两天：你出生的那天和你想明白自己为什么出生在这个世界的那天”，我想我们不要急于追寻未知的自己，做好当下的自己，对于那些一直在询问“XX时候学习XX晚不晚”的想法，我想说的是“15岁觉得游泳难，放弃游泳，到18岁遇到一个你喜欢的人约你去游泳，你只好说“我不会耶”。18岁觉得英文难，放弃英文，28岁出现一个很棒但要会英文的工作，你只好说“我不会耶”。人生前期越嫌麻烦，越懒得学，后来就越可能错过让你动心的人和事，错过新风景。”</p>
<p>2016年，我大三，意味着接下来摆在我面前的将会有两条路，要么考研？要么工作？每一种选择后面都有不一样的人生。人最可悲的事情莫过于欺骗自己，当看见别人的辉煌时，我们总是想象着要是我拥有XX的环境，我也会和他一样，甚至比他优秀。可是，当我们真的拥有一样的环境时，我们会做的更好吗？可能是，也可能不是。我觉得一个人是否成功最重要是是认清自己，认清所处的环境，我们需要去适应环境。每一次，打电话给父母，父母都会劝我读研，我一直含含糊糊地回答这个问题，我知道我一直在逃避，我也不知道我接下来的路该如何走？正如我当初并没有做好上大学的准备，也就这样浑浑噩噩地度过了三年，当考研摆在我面前时，我不想再像三年前不知道如何面对大学的自己一样，我不想把我的青春浪费在无知上，我要为我做出的每一个选择负责，同时，我也要明白自己为什么这样选择。我感觉采铜老师的这份答案蛮不错的，建议每一个迷茫的大学生看看。<a href="https://www.zhihu.com/question/20079854/answer/15158846" title="大学和职场的脱节" target="_blank" rel="external">https://www.zhihu.com/question/20079854/answer/15158846</a></p>
<p>最后，我希望自己在2016年只要做好两件事就可以了，即读书与反思。<br><img src="http://i.imgur.com/LtOVsT0.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015已经悄然逝去，早已忘却2015年的计划，每一年的开始，我都会满怀信心的写下自己的计划，等到年末的时候，拿出来才发现并没有几个计划如愿以偿地完成，然后，又继续重新欺骗自己，这样的岁月一载又一载，想想就会令人发笑。2016是否会继续下去？我的内心发出“不，我要不一样的2]]>
    </summary>
    
      <category term="生活" scheme="http://dsljlbaby.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://dsljlbaby.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫基础（一）]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/02/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://dsljlbaby.github.io/2016/01/02/Python爬虫基础（一）/</id>
    <published>2016-01-02T01:53:50.000Z</published>
    <updated>2016-01-02T07:29:34.123Z</updated>
    <content type="html"><![CDATA[<p>大家好，最近博主在学习Python，每天只是Print，感觉好枯燥，所以打算利用学习网络爬虫来加深自己的Python功底，在此将自己的学习系统地整理下来，如果大家有兴趣学习爬虫的话，可以将这些文章作为参考，也欢迎大家一共分享学习经验。</p>
<h2 id="u7F51_u7EDC_u722C_u866B_u7684_u57FA_u672C_u4ECB_u7ECD"><a href="#u7F51_u7EDC_u722C_u866B_u7684_u57FA_u672C_u4ECB_u7ECD" class="headerlink" title="网络爬虫的基本介绍"></a>网络爬虫的基本介绍</h2><p>学习爬虫，我想主要从以下几个方面来切入</p>
<ul>
<li>爬虫的原理？</li>
<li>爬虫的作用？</li>
<li>爬虫的实现？</li>
<li>爬虫的工具？</li>
</ul>
<h2 id="u722C_u866B_u7684_u539F_u7406"><a href="#u722C_u866B_u7684_u539F_u7406" class="headerlink" title="爬虫的原理"></a>爬虫的原理</h2><p>爬虫就是一种自动获取网页内容，提取有价值的数据的技术。把互联网比喻成一个蜘蛛网，把你想象成一只蜘蛛，如果要你浏览全部网页，你会如何进行？从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，然后通过这些链接地址寻找下一个网页，这样一直循环下去，直到把这个网站所有的网页都抓取完为止。网络爬虫的基本操作是抓取网页。</p>
<h2 id="u722C_u866B_u7684_u4F5C_u7528"><a href="#u722C_u866B_u7684_u4F5C_u7528" class="headerlink" title="爬虫的作用"></a>爬虫的作用</h2><p>方便获取互联网数据，为我所用。假如你是一个科幻迷，想要获取豆瓣上关于科幻电影的信息，你就可以通过写一个简单的脚本，去抓取关于科幻电影的信息。又或者朋友向你推荐一部好看的动漫，你想要下载整部动漫时，你也可以写个爬虫程序，去获取下载链接。</p>
<h2 id="u722C_u866B_u7684_u5B9E_u73B0"><a href="#u722C_u866B_u7684_u5B9E_u73B0" class="headerlink" title="爬虫的实现"></a>爬虫的实现</h2><p><img src="http://i.imgur.com/AJenPpZ.png" alt=""></p>
<p>爬虫实现的过程中主要包括了抓取网页、存储、网页分析、展示预期结果。</p>
<h2 id="u722C_u866B_u7684_u5DE5_u5177"><a href="#u722C_u866B_u7684_u5DE5_u5177" class="headerlink" title="爬虫的工具"></a>爬虫的工具</h2><p>刚开始学习爬虫，我们需要掌握以下几个库的使用。</p>
<ol>
<li>打开网页，下载文件：urllib、urllib2</li>
<li>解析网页：BeautifulSoup，熟悉JQuery的可以用Pyquery </li>
<li>使用Requests来提交各种类型的请求，支持重定向，cookies等。</li>
<li>使用Selenium，模拟浏览器提交类似用户的操作，处理js动态产生的网页</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>大家好，最近博主在学习Python，每天只是Print，感觉好枯燥，所以打算利用学习网络爬虫来加深自己的Python功底，在此将自己的学习系统地整理下来，如果大家有兴趣学习爬虫的话，可以将这些文章作为参考，也欢迎大家一共分享学习经验。</p>
<h2 id="u7F51_u]]>
    </summary>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://dsljlbaby.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫基础（二）]]></title>
    <link href="http://dsljlbaby.github.io/2016/01/02/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://dsljlbaby.github.io/2016/01/02/Python爬虫基础（二）/</id>
    <published>2016-01-02T01:44:33.000Z</published>
    <updated>2016-01-02T01:57:09.657Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们大概地了解了网络爬虫的一些基本知识，这篇博文主要讲述下我们平时浏览网页时，浏览器如何响应我们的访问以及URL、URI的相关知识。</p>
<p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫学习有很大帮助。</p>
<h2 id="u6D4F_u89C8_u7F51_u9875_u7684_u8FC7_u7A0B"><a href="#u6D4F_u89C8_u7F51_u9875_u7684_u8FC7_u7A0B" class="headerlink" title="浏览网页的过程"></a>浏览网页的过程</h2><p>用户在浏览器中输入我们想要查询的信息后，浏览器就会作为一个客户端，经过DNS服务器，找到服务器主机，向服务器发出一个请求，服务器经过解析之后，发送给用户的浏览器 HTML、JS、CSS 等文件，浏览器解析出来，用户便可以看到我们所需要的信息啦。</p>
<p>浏览器的功能是将获取到的HTML代码进行解析，然后将原始的代码转变成我们直接看到的网站页面。</p>
<p>HTML是一种标记语言，用标签标记内容并加以解析和区分</p>
<p>因此，抓取网页的过程其实和用户平时使用浏览器浏览网页的道理是一样的。用户看到的网页实质是由 HTML 代码构成的，爬虫爬来的便是这些内容，通过分析和过滤这些 HTML 代码，实现对图片、文字等资源的获取。</p>
<h2 id="URI_u548CURL_u7684_u8BA4_u8BC6"><a href="#URI_u548CURL_u7684_u8BA4_u8BC6" class="headerlink" title="URI和URL的认识"></a>URI和URL的认识</h2><p>在爬虫的实现中，我们曾提到调度器首先要从URL管理器中获得URL，才可以进行下一步的访问。那么URL是什么呢？简单的来讲，URL就是在浏览器端输入一个要访问的网址，比如说百度首页的网址    <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>    就是一个URL。</p>
<p>在理解URL（统一资源定位符）之前，我们还是首先理解下URI（统一资源标识符）的概念。</p>
<h3 id="u4EC0_u4E48_u662FURI_uFF1F"><a href="#u4EC0_u4E48_u662FURI_uFF1F" class="headerlink" title="什么是URI？"></a>什么是URI？</h3><p>Web上每种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个通用资源标志符(Universal Resource Identifier， URI)进行定位。 </p>
<p>URI通常由三部分组成：</p>
<ol>
<li>访问资源的命名机制；</li>
<li>存放资源的主机名；</li>
<li>资源自身的名称，由路径表示。</li>
</ol>
<p>如下面的URI：</p>
<p><a href="http://mooc.guokr.com/html/html21/" target="_blank" rel="external">http://mooc.guokr.com/html/html21/</a></p>
<p>我们可以这样解释它：</p>
<ol>
<li>这是一个可以通过HTTP协议访问的资源,使用http:或者https:等协议方案名获取资源时需要制定协议类型。</li>
<li>位于主机mooc.guokr.com上。</li>
<li>通过路径”/html/html21”访问。</li>
</ol>
<h3 id="u4EC0_u4E48_u662FURL_uFF1F"><a href="#u4EC0_u4E48_u662FURL_uFF1F" class="headerlink" title="什么是URL？"></a>什么是URL？</h3><p>URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位符”。也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。</p>
<p>URL的一般格式为(带方括号[]的为可选项)：<br>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</p>
<p>同样地，URL的格式也主要由三部分组成： </p>
<ol>
<li>第一部分是协议(或称为服务方式)。</li>
<li>第二部分是存有该资源的主机IP地址(有时也包括端口号)。</li>
<li>第三部分是主机资源的具体地址，如目录和文件名等。<br>第一部分和第二部分用“://”符号隔开，</li>
</ol>
<p>第二部分和第三部分用“/”符号隔开。</p>
<p>第一部分和第二部分是不可缺少的，第三部分有时可以省略。</p>
<p>如下面的URL：</p>
<p><a href="https://www.coursera.org/course/interactivepython1" target="_blank" rel="external">https://www.coursera.org/course/interactivepython1</a></p>
<ol>
<li>这是一个可以通过HTTPS协议访问的资源</li>
<li>计算机域名是www.coursera.org</li>
<li>interactivepython1存放在主机www.coursera.org上的目录/course下</li>
</ol>
<h3 id="URL_u548CURI_u7684_u533A_u522B"><a href="#URL_u548CURI_u7684_u533A_u522B" class="headerlink" title="URL和URI的区别"></a>URL和URI的区别</h3><p>URL是URI的一个子集，URI表示请求服务器的路径，定义这么一个资源，而URL同时说明要如何访问这个资源（http://）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们大概地了解了网络爬虫的一些基本知识，这篇博文主要讲述下我们平时浏览网页时，浏览器如何响应我们的访问以及URL、URI的相关知识。</p>
<p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫]]>
    </summary>
    
      <category term="Python" scheme="http://dsljlbaby.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://dsljlbaby.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
